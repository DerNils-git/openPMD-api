<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>openPMD-api: openPMD::AbstractIOHandlerImpl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openPMD-api
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopen_p_m_d.html">openPMD</a></li><li class="navelem"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html">AbstractIOHandlerImpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">openPMD::AbstractIOHandlerImpl Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for openPMD::AbstractIOHandlerImpl:</div>
<div class="dyncontent">
<div class="center"><img src="classopen_p_m_d_1_1_abstract_i_o_handler_impl__inherit__graph.png" border="0" usemap="#open_p_m_d_1_1_abstract_i_o_handler_impl_inherit__map" alt="Inheritance graph"/></div>
<map name="open_p_m_d_1_1_abstract_i_o_handler_impl_inherit__map" id="open_p_m_d_1_1_abstract_i_o_handler_impl_inherit__map">
<area shape="rect" title=" " alt="" coords="255,5,495,32"/>
<area shape="rect" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html" title=" " alt="" coords="5,80,240,107"/>
<area shape="rect" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html" title=" " alt="" coords="263,80,486,107"/>
<area shape="rect" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html" title=" " alt="" coords="511,80,729,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for openPMD::AbstractIOHandlerImpl:</div>
<div class="dyncontent">
<div class="center"><img src="classopen_p_m_d_1_1_abstract_i_o_handler_impl__coll__graph.png" border="0" usemap="#open_p_m_d_1_1_abstract_i_o_handler_impl_coll__map" alt="Collaboration graph"/></div>
<map name="open_p_m_d_1_1_abstract_i_o_handler_impl_coll__map" id="open_p_m_d_1_1_abstract_i_o_handler_impl_coll__map">
<area shape="rect" title=" " alt="" coords="173,496,413,523"/>
<area shape="rect" href="classopen_p_m_d_1_1_abstract_i_o_handler.html" title="Interface for communicating between logical and physically persistent data." alt="" coords="187,407,398,433"/>
<area shape="rect" title=" " alt="" coords="135,303,301,344"/>
<area shape="rect" href="classopen_p_m_d_1_1_i_o_task.html" title="Self&#45;contained description of a single IO operation." alt="" coords="144,206,279,233"/>
<area shape="rect" title=" " alt="" coords="15,95,211,136"/>
<area shape="rect" href="structopen_p_m_d_1_1_abstract_parameter.html" title=" " alt="" coords="5,5,220,32"/>
<area shape="rect" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file." alt="" coords="235,102,382,129"/>
<area shape="rect" title="STL class." alt="" coords="328,310,415,337"/>
<area shape="rect" title="STL class." alt="" coords="303,199,442,240"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72ebfa6a03e69d9198c29df56b3c162b"><td class="memItemLeft" align="right" valign="top"><a id="a72ebfa6a03e69d9198c29df56b3c162b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AbstractIOHandlerImpl</b> (<a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> *handler)</td></tr>
<tr class="separator:a72ebfa6a03e69d9198c29df56b3c162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df9e1672a54a8f738373cf2370205bd"><td class="memItemLeft" align="right" valign="top"><a id="a1df9e1672a54a8f738373cf2370205bd"></a>
virtual std::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()</td></tr>
<tr class="separator:a1df9e1672a54a8f738373cf2370205bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae81455a482ab0a5751cb9de9b9e34ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#aae81455a482ab0a5751cb9de9b9e34ba">closeFile</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CLOSE_FILE &gt; const &amp;)=0</td></tr>
<tr class="memdesc:aae81455a482ab0a5751cb9de9b9e34ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the file corresponding with the writable and release file handles.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#aae81455a482ab0a5751cb9de9b9e34ba">More...</a><br /></td></tr>
<tr class="separator:aae81455a482ab0a5751cb9de9b9e34ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd08f8978fc0c6a72b0e251674eff0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ad9dd08f8978fc0c6a72b0e251674eff0">advance</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::ADVANCE &gt; &amp;)</td></tr>
<tr class="memdesc:ad9dd08f8978fc0c6a72b0e251674eff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the file/stream that this writable belongs to.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ad9dd08f8978fc0c6a72b0e251674eff0">More...</a><br /></td></tr>
<tr class="separator:ad9dd08f8978fc0c6a72b0e251674eff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23693917e2cb75976e6ea6c947d85f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a7c23693917e2cb75976e6ea6c947d85f">closePath</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CLOSE_PATH &gt; const &amp;)</td></tr>
<tr class="memdesc:a7c23693917e2cb75976e6ea6c947d85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> group.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a7c23693917e2cb75976e6ea6c947d85f">More...</a><br /></td></tr>
<tr class="separator:a7c23693917e2cb75976e6ea6c947d85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0bdf651d13b244b6ed8ca57218144"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a6ad0bdf651d13b244b6ed8ca57218144">availableChunks</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::AVAILABLE_CHUNKS &gt; &amp;)=0</td></tr>
<tr class="memdesc:a6ad0bdf651d13b244b6ed8ca57218144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report chunks that are available for loading from the dataset represented by this writable.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a6ad0bdf651d13b244b6ed8ca57218144">More...</a><br /></td></tr>
<tr class="separator:a6ad0bdf651d13b244b6ed8ca57218144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad501362ff4599acc66d2a3358b5a9149"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ad501362ff4599acc66d2a3358b5a9149">createFile</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CREATE_FILE &gt; const &amp;)=0</td></tr>
<tr class="memdesc:ad501362ff4599acc66d2a3358b5a9149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new file in physical storage, possibly overriding an existing file.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ad501362ff4599acc66d2a3358b5a9149">More...</a><br /></td></tr>
<tr class="separator:ad501362ff4599acc66d2a3358b5a9149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ebc0452e248b2059995f5b78a67a87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a99ebc0452e248b2059995f5b78a67a87">createPath</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CREATE_PATH &gt; const &amp;)=0</td></tr>
<tr class="memdesc:a99ebc0452e248b2059995f5b78a67a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create all necessary groups for a path, possibly recursively.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a99ebc0452e248b2059995f5b78a67a87">More...</a><br /></td></tr>
<tr class="separator:a99ebc0452e248b2059995f5b78a67a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71531a8a7d4efeb210a4c58e0fd1ea2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a71531a8a7d4efeb210a4c58e0fd1ea2e">createDataset</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CREATE_DATASET &gt; const &amp;)=0</td></tr>
<tr class="memdesc:a71531a8a7d4efeb210a4c58e0fd1ea2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dataset of given type, extent and storage properties.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a71531a8a7d4efeb210a4c58e0fd1ea2e">More...</a><br /></td></tr>
<tr class="separator:a71531a8a7d4efeb210a4c58e0fd1ea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67863e045adde85a9b5cf743e97c3c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ac67863e045adde85a9b5cf743e97c3c4">extendDataset</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::EXTEND_DATASET &gt; const &amp;)=0</td></tr>
<tr class="memdesc:ac67863e045adde85a9b5cf743e97c3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the extent of an existing dataset.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ac67863e045adde85a9b5cf743e97c3c4">More...</a><br /></td></tr>
<tr class="separator:ac67863e045adde85a9b5cf743e97c3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2a624108095732530bf900bc478f53"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a5e2a624108095732530bf900bc478f53">openFile</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::OPEN_FILE &gt; const &amp;)=0</td></tr>
<tr class="memdesc:a5e2a624108095732530bf900bc478f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an existing file assuming it conforms to <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a>.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a5e2a624108095732530bf900bc478f53">More...</a><br /></td></tr>
<tr class="separator:a5e2a624108095732530bf900bc478f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b85b4bf85435804def41a2b335c952"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#af1b85b4bf85435804def41a2b335c952">openPath</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::OPEN_PATH &gt; const &amp;)=0</td></tr>
<tr class="memdesc:af1b85b4bf85435804def41a2b335c952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open all contained groups in a path, possibly recursively.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#af1b85b4bf85435804def41a2b335c952">More...</a><br /></td></tr>
<tr class="separator:af1b85b4bf85435804def41a2b335c952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884b0da0f517cbfcd36e359a6fdbbff8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a884b0da0f517cbfcd36e359a6fdbbff8">openDataset</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::OPEN_DATASET &gt; &amp;)=0</td></tr>
<tr class="memdesc:a884b0da0f517cbfcd36e359a6fdbbff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an existing dataset and determine its datatype and extent.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a884b0da0f517cbfcd36e359a6fdbbff8">More...</a><br /></td></tr>
<tr class="separator:a884b0da0f517cbfcd36e359a6fdbbff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acede3c709083bee5b89e19ee883e843f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#acede3c709083bee5b89e19ee883e843f">deleteFile</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_FILE &gt; const &amp;)=0</td></tr>
<tr class="memdesc:acede3c709083bee5b89e19ee883e843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing file from physical storage.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#acede3c709083bee5b89e19ee883e843f">More...</a><br /></td></tr>
<tr class="separator:acede3c709083bee5b89e19ee883e843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af006b4c69e15e42b4cccdce9be407d92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#af006b4c69e15e42b4cccdce9be407d92">deletePath</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_PATH &gt; const &amp;)=0</td></tr>
<tr class="memdesc:af006b4c69e15e42b4cccdce9be407d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all objects within an existing path.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#af006b4c69e15e42b4cccdce9be407d92">More...</a><br /></td></tr>
<tr class="separator:af006b4c69e15e42b4cccdce9be407d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d1487961ae77a8fd17d4fed5b69649"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a05d1487961ae77a8fd17d4fed5b69649">deleteDataset</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_DATASET &gt; const &amp;)=0</td></tr>
<tr class="memdesc:a05d1487961ae77a8fd17d4fed5b69649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing dataset.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a05d1487961ae77a8fd17d4fed5b69649">More...</a><br /></td></tr>
<tr class="separator:a05d1487961ae77a8fd17d4fed5b69649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c3134388a0f69713ab44ae6219f3e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#acd6c3134388a0f69713ab44ae6219f3e">deleteAttribute</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_ATT &gt; const &amp;)=0</td></tr>
<tr class="memdesc:acd6c3134388a0f69713ab44ae6219f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing attribute.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#acd6c3134388a0f69713ab44ae6219f3e">More...</a><br /></td></tr>
<tr class="separator:acd6c3134388a0f69713ab44ae6219f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a29cc773e10f51ada54dd0128f87d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a64a29cc773e10f51ada54dd0128f87d8">writeDataset</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::WRITE_DATASET &gt; const &amp;)=0</td></tr>
<tr class="memdesc:a64a29cc773e10f51ada54dd0128f87d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a chunk of data into an existing dataset.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a64a29cc773e10f51ada54dd0128f87d8">More...</a><br /></td></tr>
<tr class="separator:a64a29cc773e10f51ada54dd0128f87d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f11e01e5a2f92c5c533ba0b03072df6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a3f11e01e5a2f92c5c533ba0b03072df6">getBufferView</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::GET_BUFFER_VIEW &gt; &amp;parameters)</td></tr>
<tr class="memdesc:a3f11e01e5a2f92c5c533ba0b03072df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a view into a dataset buffer that can be filled by a user.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a3f11e01e5a2f92c5c533ba0b03072df6">More...</a><br /></td></tr>
<tr class="separator:a3f11e01e5a2f92c5c533ba0b03072df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac895fcbc53b2aea756559f7143e42b9b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ac895fcbc53b2aea756559f7143e42b9b">writeAttribute</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::WRITE_ATT &gt; const &amp;)=0</td></tr>
<tr class="memdesc:ac895fcbc53b2aea756559f7143e42b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a single attribute and fill the value, possibly overwriting an existing attribute.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ac895fcbc53b2aea756559f7143e42b9b">More...</a><br /></td></tr>
<tr class="separator:ac895fcbc53b2aea756559f7143e42b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ffcaed2481904cec1b870916696c47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a16ffcaed2481904cec1b870916696c47">readDataset</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::READ_DATASET &gt; &amp;)=0</td></tr>
<tr class="memdesc:a16ffcaed2481904cec1b870916696c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a chunk of data from an existing dataset.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a16ffcaed2481904cec1b870916696c47">More...</a><br /></td></tr>
<tr class="separator:a16ffcaed2481904cec1b870916696c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97199cf24a6c858495efe510f0385d8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a97199cf24a6c858495efe510f0385d8e">readAttribute</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::READ_ATT &gt; &amp;)=0</td></tr>
<tr class="memdesc:a97199cf24a6c858495efe510f0385d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of an existing attribute.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a97199cf24a6c858495efe510f0385d8e">More...</a><br /></td></tr>
<tr class="separator:a97199cf24a6c858495efe510f0385d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ac6771e110b8606cdcf20ce11a7373"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ab4ac6771e110b8606cdcf20ce11a7373">listPaths</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::LIST_PATHS &gt; &amp;)=0</td></tr>
<tr class="memdesc:ab4ac6771e110b8606cdcf20ce11a7373"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all paths/sub-groups inside a group, non-recursively.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#ab4ac6771e110b8606cdcf20ce11a7373">More...</a><br /></td></tr>
<tr class="separator:ab4ac6771e110b8606cdcf20ce11a7373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb665b347a03054539e4a4cc8777a24a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#aeb665b347a03054539e4a4cc8777a24a">listDatasets</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::LIST_DATASETS &gt; &amp;)=0</td></tr>
<tr class="memdesc:aeb665b347a03054539e4a4cc8777a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all datasets inside a group, non-recursively.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#aeb665b347a03054539e4a4cc8777a24a">More...</a><br /></td></tr>
<tr class="separator:aeb665b347a03054539e4a4cc8777a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebaa1891bf8502801ca9ec7cbb7b427"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a4ebaa1891bf8502801ca9ec7cbb7b427">listAttributes</a> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *, <a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::LIST_ATTS &gt; &amp;)=0</td></tr>
<tr class="memdesc:a4ebaa1891bf8502801ca9ec7cbb7b427"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all attributes associated with an object.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html#a4ebaa1891bf8502801ca9ec7cbb7b427">More...</a><br /></td></tr>
<tr class="separator:a4ebaa1891bf8502801ca9ec7cbb7b427"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:acf92f586e73df15e9f6ff9edf0ec855d"><td class="memItemLeft" align="right" valign="top"><a id="acf92f586e73df15e9f6ff9edf0ec855d"></a>
<a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_handler</b></td></tr>
<tr class="separator:acf92f586e73df15e9f6ff9edf0ec855d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9dd08f8978fc0c6a72b0e251674eff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dd08f8978fc0c6a72b0e251674eff0">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::ADVANCE &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the file/stream that this writable belongs to. </p>
<p>If the backend is based around usage of IO steps (especially streaming backends), open or close an IO step. This is modeled closely after the step concept in ADIOS2.</p>
<p>This task is used to implement streaming-aware semantics in the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> API by splitting data into packets that are written to and read from transport.</p>
<p>IO actions up to the point of closing a step must be performed now.</p>
<p>The advance mode is determined by parameters.mode. The return status code shall be stored as parameters.status. </p>

</div>
</div>
<a id="a6ad0bdf651d13b244b6ed8ca57218144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0bdf651d13b244b6ed8ca57218144">&#9670;&nbsp;</a></span>availableChunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::availableChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::AVAILABLE_CHUNKS &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report chunks that are available for loading from the dataset represented by this writable. </p>
<p>The resulting chunks should be stored into parameters.chunks. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a10df0cf9d242c1096e313e934437eb00">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a99e5b58cbb33140079b9bc7076d9ea81">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a4733f9bd0c697dc58468fd91411b4742">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="aae81455a482ab0a5751cb9de9b9e34ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae81455a482ab0a5751cb9de9b9e34ba">&#9670;&nbsp;</a></span>closeFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::closeFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CLOSE_FILE &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the file corresponding with the writable and release file handles. </p>
<p>The operation should succeed in any access mode. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#ab83373e4587f846e21fe3bfa3b8ecffc">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a6f3becdf325d6da3d1912381998a1c50">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a2ec4ab616fead11b551d9dca6bc72b19">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a7c23693917e2cb75976e6ea6c947d85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c23693917e2cb75976e6ea6c947d85f">&#9670;&nbsp;</a></span>closePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::closePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CLOSE_PATH &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> group. </p>
<p>This is an optimization-enabling task and may be ignored by backends. Indicates that the group will not be accessed any further. Especially in step-based IO mode (e.g. streaming): Indicates that the group corresponding with the writable needs not be held in a parseable state for this and upcoming IO steps, allowing for deletion of metadata to be sent/stored (attributes, datasets, ..). Should fail if the writable is not written. Should fail if m_handler-&gt;accessType is AccessType::READ_ONLY. </p>

</div>
</div>
<a id="a71531a8a7d4efeb210a4c58e0fd1ea2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71531a8a7d4efeb210a4c58e0fd1ea2e">&#9670;&nbsp;</a></span>createDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::createDataset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CREATE_DATASET &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dataset of given type, extent and storage properties. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The path may contain multiple levels (e.g. group/dataset). The new dataset should have the name parameters.name. This name should not start or end with a slash ("/"). The new dataset should be of datatype parameters.dtype. The new dataset should have an extent of parameters.extent. If possible, the new dataset should be extensible. If possible, the new dataset should be divided into chunks with size parameters.chunkSize. If possible, the new dataset should be compressed according to parameters.compression. This may be format-specific. If possible, the new dataset should be transformed accoring to parameters.transform. This may be format-specific. The Writables file position should correspond to the newly created dataset. The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#ac1b32c5456db7c6b90029fd5cf186006">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#aaec53b0f23308ad9e38d1284ce65f677">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a04d8af7e377f4defd01cc82ed3d08969">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="ad501362ff4599acc66d2a3358b5a9149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad501362ff4599acc66d2a3358b5a9149">&#9670;&nbsp;</a></span>createFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::createFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CREATE_FILE &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new file in physical storage, possibly overriding an existing file. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The new file should be located in m_handler-&gt;directory. The new file should have the filename parameters.name. The filename should include the correct corresponding filename extension. Any existing file should be overwritten if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea294ce20cdefa29be3be0735cb62e715d" title="create new series and truncate existing (files)">Access::CREATE</a>. The Writables file position should correspond to the root group "/" of the hierarchy. The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a91484c719cb4b1a43253d3c677566022">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a6422a5898330dbb8627e3712300fae94">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a71f2ce49e93622a6f848451d66e630a9">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a99ebc0452e248b2059995f5b78a67a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ebc0452e248b2059995f5b78a67a87">&#9670;&nbsp;</a></span>createPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::createPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::CREATE_PATH &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create all necessary groups for a path, possibly recursively. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The path parameters.path may contain multiple levels (e.g. first/second/third/). The Writables file position should correspond to the complete newly created path (i.e. first/second/third/ should be assigned to the Writables file position). The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a07171d12df218ad79fc27b4cfc091c7f">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#ab0df8504766454b96ccdb677c739b989">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#ad95f8d3416d90f560df97f44faaa756a">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="acd6c3134388a0f69713ab44ae6219f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6c3134388a0f69713ab44ae6219f3e">&#9670;&nbsp;</a></span>deleteAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::deleteAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_ATT &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an existing attribute. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The operation should pass if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. The attribute should be associated with the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> and have the name parameters.name before deletion. The attribute should not be accessible in physical storage after the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a4322d8de9450393fec7ca9d59a18f56f">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a12a19af7e80d17e715dd240193ed9cc1">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a124310c079630f30aba75ed2ff0cc8a0">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a05d1487961ae77a8fd17d4fed5b69649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d1487961ae77a8fd17d4fed5b69649">&#9670;&nbsp;</a></span>deleteDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::deleteDataset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_DATASET &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an existing dataset. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The operation should pass if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. The dataset should have the name parameters.name. This name should not start or end with a slash ("/"). It may also contain the current dataset ".". The dataset should not be accessible in physical storage after the operation completes successfully. The Writables file position should be set to an invalid position (i.e. the pointer should be a nullptr). The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked not written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#ac50881472d57f29d66dae0dfff50f93b">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a1da6b48d01e55a6172284e9c14bbe5bc">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a3221bf13c55a0c876941fdcb145dae75">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="acede3c709083bee5b89e19ee883e843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acede3c709083bee5b89e19ee883e843f">&#9670;&nbsp;</a></span>deleteFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::deleteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_FILE &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an existing file from physical storage. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The operation should pass if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. All handles that correspond to the file should be closed before deletion. The file to delete should have the filename parameters.name. The filename should include the correct corresponding filename extension. The Writables file position should be set to an invalid position (i.e. the pointer should be a nullptr). The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked not written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a95fdc087b4af8954dfeb8af029781ad0">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#af361243e9acb2647836d388ce8688a18">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a6e08f1ddcbf972c0088d6aae708007aa">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="af006b4c69e15e42b4cccdce9be407d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af006b4c69e15e42b4cccdce9be407d92">&#9670;&nbsp;</a></span>deletePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::deletePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::DELETE_PATH &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all objects within an existing path. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The operation should pass if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. The path parameters.path may contain multiple levels (e.g. first/second/third/). This path should be relative (i.e. it should not start with a slash "/"). It may also contain the current group ".". All groups and datasets starting from the path should not be accessible in physical storage after the operation completes successfully. The Writables file position should be set to an invalid position (i.e. the pointer should be a nullptr). The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked not written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a64154e8f54d2d4b11baee9f75fd9b9dd">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a2bfbb84e4a9c4cf9a1cb1225b77b641e">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#acddc61d539ca475e0fcc3982b8c6cb0f">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="ac67863e045adde85a9b5cf743e97c3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67863e045adde85a9b5cf743e97c3c4">&#9670;&nbsp;</a></span>extendDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::extendDataset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::EXTEND_DATASET &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the extent of an existing dataset. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The operation should fail if the dataset does not yet exist. The dataset should have the name parameters.name. This name should not start or end with a slash ("/"). The operation should fail if the new extent is not strictly large in every dimension. The dataset should have an extent of parameters.extent. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#ace23df4888c783b6d8105126236d542e">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a04586f99f4927e37895e69f40b016573">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a42dc6e4ae43f294b5b0b7381faa298a2">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a3f11e01e5a2f92c5c533ba0b03072df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f11e01e5a2f92c5c533ba0b03072df6">&#9670;&nbsp;</a></span>getBufferView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::getBufferView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::GET_BUFFER_VIEW &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a view into a dataset buffer that can be filled by a user. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The dataset should be associated with the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a>. The operation should fail if the dataset does not exist. The operation should fail if the chunk extent parameters.extent is not smaller or equals in every dimension. The operation should fail if chunk positions parameters.offset+parameters.extent do not reside inside the dataset. The dataset should match the dataype parameters.dtype. The buffer should be stored as a cast-to-char pointer to a flattened version of the backend buffer in parameters.out-&gt;ptr. The chunk is stored row-major. The buffer's content should be written to storage not before the next call to <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html#a01a69dc408cc40dab0af0ab3bb0a75d8" title="Process operations in queue according to FIFO.">AbstractIOHandler::flush</a> where AbstractIOHandler::m_flushLevel == <a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065ada1e0af0851f992af15f8837cb34b087" title="Default mode, used when flushes are triggered internally, e.g.">FlushLevel::InternalFlush</a>. The precise time of data consumption is defined by the backend:</p><ul>
<li>Data written to the returned buffer should be consumed not earlier than the next call to <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html#a01a69dc408cc40dab0af0ab3bb0a75d8" title="Process operations in queue according to FIFO.">AbstractIOHandler::flush</a> where AbstractIOHandler::m_flushLevel == <a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065ada1e0af0851f992af15f8837cb34b087" title="Default mode, used when flushes are triggered internally, e.g.">FlushLevel::InternalFlush</a>.</li>
<li>Data should be consumed not later than the next Operation::ADVANCE task where parameter.mode == AdvanceMode::ENDSTEP.</li>
</ul>
<p>This <a class="el" href="classopen_p_m_d_1_1_i_o_task.html" title="Self-contained description of a single IO operation.">IOTask</a> is optional and should either (1) not be implemented by a backend at all or (2) be implemented as indicated above and set parameters.out-&gt;backendManagedBuffer = true. </p>

</div>
</div>
<a id="a4ebaa1891bf8502801ca9ec7cbb7b427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebaa1891bf8502801ca9ec7cbb7b427">&#9670;&nbsp;</a></span>listAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::listAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::LIST_ATTS &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all attributes associated with an object. </p>
<p>The operation should fail if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. The attribute should be associated with the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a>. The list of attribute names should be stored in the location indicated by the pointer parameters.attributes. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a1de6df826c79320e88e0ca9b86a218ab">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a770a05548a5f2863a220732e4f9b43b6">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a9493f3b8c7b0ba4f4fd9f6d41c1f6752">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="aeb665b347a03054539e4a4cc8777a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb665b347a03054539e4a4cc8777a24a">&#9670;&nbsp;</a></span>listDatasets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::listDatasets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::LIST_DATASETS &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all datasets inside a group, non-recursively. </p>
<p>The operation should fail if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. The operation should fail if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> is not a group. The list of dataset names should be stored in the location indicated by the pointer parameters.datasets. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#aba30aa65179a20e87e23e6785d458237">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a0fcf7b9595a0477fe1377b5df84e022a">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a674ab3624944b80164a7432170aa3fa1">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="ab4ac6771e110b8606cdcf20ce11a7373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ac6771e110b8606cdcf20ce11a7373">&#9670;&nbsp;</a></span>listPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::listPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::LIST_PATHS &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all paths/sub-groups inside a group, non-recursively. </p>
<p>The operation should fail if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. The operation should fail if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> is not a group. The list of group names should be stored in the location indicated by the pointer parameters.paths. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#aa8f8b6a5e2871d704ef36c0adc7b4289">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a44190eecb7edb744ea57a4b25ce0b7a1">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a250bf4ebfa0eaf1240585af922b9d0a7">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a884b0da0f517cbfcd36e359a6fdbbff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884b0da0f517cbfcd36e359a6fdbbff8">&#9670;&nbsp;</a></span>openDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::openDataset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::OPEN_DATASET &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open an existing dataset and determine its datatype and extent. </p>
<p>The opened dataset should be located in a group below the group of the Writables parent writable-&gt;parent. The opened datasets name should be parameters.name. This name should not start or end with a slash ("/"). The opened datasets datatype should be stored in *(parameters.dtype). The opened datasets extent should be stored in *(parameters.extent). The Writables file position should correspond to the opened dataset. The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a56a0ee144ed00449f3f4c4b7b9a42259">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#adf2494006be374755b06b3f051de4ad3">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a981c5d47cad6c8fcb14a0b03115bc8ea">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a5e2a624108095732530bf900bc478f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2a624108095732530bf900bc478f53">&#9670;&nbsp;</a></span>openFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::openFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::OPEN_FILE &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open an existing file assuming it conforms to <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a>. </p>
<p>The operation should fail if m_handler-&gt;directory is not accessible. The opened file should have filename parameters.name and include the correct corresponding filename extension. The operation should not open files more than once. If possible, the file should be opened with read-only permissions if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The Writables file position should correspond to the root group "/" of the hierarchy in the opened file. The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#ae27065ca1303268f0412fd741295156b">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a43dc1969f61f27a44432650bdab1b33a">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a6e6145c8047f80c1aab102bfe52131e0">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="af1b85b4bf85435804def41a2b335c952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b85b4bf85435804def41a2b335c952">&#9670;&nbsp;</a></span>openPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::openPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::OPEN_PATH &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open all contained groups in a path, possibly recursively. </p>
<p>The operation should overwrite existing file positions, even when the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was already marked written. The path parameters.path may contain multiple levels (e.g. first/second/third/). This path should be relative (i.e. it should not start with a slash "/"). The number of levels may be zero, i.e. parameters.path may be an empty string. The Writables file position should correspond to the complete opened path (i.e. first/second/third/ should be assigned to the Writables file position). The <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> should be marked written when the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a2cacb15fb7ddec2b58ab95da0077340f">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a02f4eaa396e166ef6e0eb36e238d676c">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#ae4287cc3b54abfff713b5b26879a5eaf">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a97199cf24a6c858495efe510f0385d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97199cf24a6c858495efe510f0385d8e">&#9670;&nbsp;</a></span>readAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::readAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::READ_ATT &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the value of an existing attribute. </p>
<p>The operation should fail if the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> was not marked written. The operation should fail if the attribute does not exist. The attribute should be associated with the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a> and have the name parameters.name. This name should not contain a slash ("/"). The attribute datatype should be stored in the location indicated by the pointer parameters.dtype. The attribute value should be stored as a generic Variant::resource in the location indicated by the pointer parameters.resource. All datatypes of Datatype should be supported in a type-safe way. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a7cd1099708987a9b1de0a90ccaf34d74">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#acb5f1c9619d3c6d4c61d113e6e893fe5">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#ad5bcd3cb2e0cf0066ccf5e23d63c8ce8">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a16ffcaed2481904cec1b870916696c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ffcaed2481904cec1b870916696c47">&#9670;&nbsp;</a></span>readDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::readDataset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::READ_DATASET &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a chunk of data from an existing dataset. </p>
<p>The dataset should be associated with the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a>. The operation should fail if the dataset does not exist. The operation should fail if the chunk extent parameters.extent is not smaller or equals in every dimension. The operation should fail if chunk positions parameters.offset+parameters.extent do not reside inside the dataset. The dataset should match the dataype parameters.dtype. The data parameters.data should be a cast-to-void pointer to a flattened version of the chunk data. The chunk should be stored row-major. The region of the chunk should be written to the location indicated by the pointer after the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a3ed35bf294f39ed1c86c152cfb5821d5">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#aab89ba7d6bd30c1ce74310e11e9f4107">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a640c9a29c822276b6ce31a8878340a7a">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="ac895fcbc53b2aea756559f7143e42b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac895fcbc53b2aea756559f7143e42b9b">&#9670;&nbsp;</a></span>writeAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::writeAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::WRITE_ATT &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a single attribute and fill the value, possibly overwriting an existing attribute. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The attribute should have the name parameters.name. This name should not contain a slash ("/"). The attribute should be of datatype parameters.dtype. Any existing attribute with the same name should be overwritten. If possible, only the value should be changed if the datatype stays the same. The attribute should be written to physical storage after the operation completes successfully. All datatypes of Datatype should be supported in a type-safe way. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#a656a553755af254dd85614f04d75270e">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a989388dccacac9b51b51f5a93e66b6d2">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a661fcd1c728422d5ade95ba1a6a267f5">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<a id="a64a29cc773e10f51ada54dd0128f87d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a29cc773e10f51ada54dd0128f87d8">&#9670;&nbsp;</a></span>writeDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void openPMD::AbstractIOHandlerImpl::writeDataset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a>&lt; Operation::WRITE_DATASET &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a chunk of data into an existing dataset. </p>
<p>The operation should fail if m_handler-&gt;m_frontendAccess is <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44" title="open series as read-only, fails if series is not found">Access::READ_ONLY</a>. The dataset should be associated with the <a class="el" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file.">Writable</a>. The operation should fail if the dataset does not exist. The operation should fail if the chunk extent parameters.extent is not smaller or equals in every dimension. The operation should fail if chunk positions parameters.offset+parameters.extent do not reside inside the dataset. The dataset should match the dataype parameters.dtype. The data parameters.data is a cast-to-void pointer to a flattened version of the chunk data. It should be re-cast to the provided datatype. The chunk is stored row-major. The region of the chunk should be written to physical storage after the operation completes successfully. </p>

<p>Implemented in <a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html#ab18c9365eccebb719fba852ed374c923">openPMD::JSONIOHandlerImpl</a>, <a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html#a0824e8e8dbf95801d3d2b549c93d65c8">openPMD::ADIOS1IOHandlerImpl</a>, and <a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html#a4220fa7460bfc9748c458a86ec7d1121">openPMD::HDF5IOHandlerImpl</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/tmp/tmp.iS0xscHoW7/openPMD-api/include/openPMD/IO/<a class="el" href="_abstract_i_o_handler_impl_8hpp_source.html">AbstractIOHandlerImpl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
