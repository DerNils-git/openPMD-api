<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>openPMD-api: openPMD Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openPMD-api
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">openPMD Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public definitions of openPMD-api.  
<a href="namespaceopen_p_m_d.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_file_position.html">AbstractFilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for communicating between logical and physically persistent data.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html">AbstractIOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl_common.html">AbstractIOHandlerImplCommon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_abstract_parameter.html">AbstractParameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_a_d_i_o_s1_file_position.html">ADIOS1FilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler.html">ADIOS1IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html">ADIOS1IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_a_d_i_o_s2_file_position.html">ADIOS2FilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s2_i_o_handler.html">ADIOS2IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s2_i_o_handler_impl.html">ADIOS2IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_attributable_interface.html">AttributableInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer to manage storage of attributes associated with file objects.  <a href="classopen_p_m_d_1_1_attributable_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Varidic datatype supporting at least all formats for attributes specified in the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> standard.  <a href="classopen_p_m_d_1_1_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_base_record.html">BaseRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_base_record_component.html">BaseRecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_block_slicer.html">BlockSlicer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to associate a thread with its local cuboid in the total cuboid.  <a href="classopen_p_m_d_1_1_block_slicer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_chunk_info.html">ChunkInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the meta info around a chunk in a dataset.  <a href="structopen_p_m_d_1_1_chunk_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_container.html">Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-like container that enforces <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> requirements and handles IO.  <a href="classopen_p_m_d_1_1_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_dataset.html">Dataset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_dataset_filler.html">DatasetFiller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class to create one iteration of data per thread.  <a href="classopen_p_m_d_1_1_dataset_filler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1decay__equiv.html">decay_equiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental equivalence check for two given types T and U.  <a href="structopen_p_m_d_1_1decay__equiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert.html">DoConvert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_u_01_4_00_01false_01_4.html">DoConvert&lt; std::vector&lt; T &gt;, std::vector&lt; U &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert_3_01_t_00_01_u_00_01false_01_4.html">DoConvert&lt; T, U, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert_3_01_t_00_01_u_00_01true_01_4.html">DoConvert&lt; T, U, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_dummy_i_o_handler.html">DummyIOHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy handler without any IO operations.  <a href="classopen_p_m_d_1_1_dummy_i_o_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_dynamic_memory_view.html">DynamicMemoryView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view into a buffer that might be reallocated at some points and thus has changing base pointers over time.  <a href="classopen_p_m_d_1_1_dynamic_memory_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_file.html">File</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_get_h5_data_type.html">GetH5DataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_h_d_f5_file_position.html">HDF5FilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler.html">HDF5IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html">HDF5IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_indexed_iteration.html">IndexedIteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="classopen_p_m_d_1_1_iteration.html" title="Logical compilation of data from one snapshot (e.g.">Iteration</a> that knows its own index withing the containing <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy.">Series</a>.  <a href="classopen_p_m_d_1_1_indexed_iteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_invalidatable_file.html">InvalidatableFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a shared pointer to:  <a href="structopen_p_m_d_1_1_invalidatable_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_i_o_task.html">IOTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-contained description of a single IO operation.  <a href="classopen_p_m_d_1_1_i_o_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_iteration.html">Iteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical compilation of data from one snapshot (e.g.  <a href="classopen_p_m_d_1_1_iteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_j_s_o_n_file_position.html">JSONFilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler.html">JSONIOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html">JSONIOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_legacy_attributable.html">LegacyAttributable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopen_p_m_d_1_1_container.html" title="Map-like container that enforces openPMD requirements and handles IO.">Container</a> for N-dimensional, homogeneous Records.  <a href="classopen_p_m_d_1_1_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_mesh_record_component.html">MeshRecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_m_p_i_benchmark.html">MPIBenchmark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a benchmark.  <a href="classopen_p_m_d_1_1_m_p_i_benchmark.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_m_p_i_benchmark_report.html">MPIBenchmarkReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The report for a single benchmark produced by &lt;openPMD/benchmark/mpi/MPIBenchmark&gt;.  <a href="structopen_p_m_d_1_1_m_p_i_benchmark_report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1no__such__attribute__error.html">no_such_attribute_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1no__such__file__error.html">no_such_file_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_one_dimensional_block_slicer.html">OneDimensionalBlockSlicer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_a_d_i_o_s1_i_o_handler.html">ParallelADIOS1IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_a_d_i_o_s1_i_o_handler_impl.html">ParallelADIOS1IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_h_d_f5_i_o_handler.html">ParallelHDF5IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_h_d_f5_i_o_handler_impl.html">ParallelHDF5IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typesafe description of all required arguments for a specified Operation.  <a href="structopen_p_m_d_1_1_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_a_d_v_a_n_c_e_01_4.html">Parameter&lt; Operation::ADVANCE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_a_v_a_i_l_a_b_l_e___c_h_u_n_k_s_01_4.html">Parameter&lt; Operation::AVAILABLE_CHUNKS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_l_o_s_e___f_i_l_e_01_4.html">Parameter&lt; Operation::CLOSE_FILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_l_o_s_e___p_a_t_h_01_4.html">Parameter&lt; Operation::CLOSE_PATH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_r_e_a_t_e___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::CREATE_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_r_e_a_t_e___f_i_l_e_01_4.html">Parameter&lt; Operation::CREATE_FILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_r_e_a_t_e___p_a_t_h_01_4.html">Parameter&lt; Operation::CREATE_PATH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___a_t_t_01_4.html">Parameter&lt; Operation::DELETE_ATT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::DELETE_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___f_i_l_e_01_4.html">Parameter&lt; Operation::DELETE_FILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___p_a_t_h_01_4.html">Parameter&lt; Operation::DELETE_PATH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_e_x_t_e_n_d___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::EXTEND_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_g_e_t___b_u_f_f_e_r___v_i_e_w_01_4.html">Parameter&lt; Operation::GET_BUFFER_VIEW &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_l_i_s_t___a_t_t_s_01_4.html">Parameter&lt; Operation::LIST_ATTS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_l_i_s_t___d_a_t_a_s_e_t_s_01_4.html">Parameter&lt; Operation::LIST_DATASETS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_l_i_s_t___p_a_t_h_s_01_4.html">Parameter&lt; Operation::LIST_PATHS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_o_p_e_n___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::OPEN_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_o_p_e_n___f_i_l_e_01_4.html">Parameter&lt; Operation::OPEN_FILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_o_p_e_n___p_a_t_h_01_4.html">Parameter&lt; Operation::OPEN_PATH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_r_e_a_d___a_t_t_01_4.html">Parameter&lt; Operation::READ_ATT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_r_e_a_d___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::READ_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_w_r_i_t_e___a_t_t_01_4.html">Parameter&lt; Operation::WRITE_ATT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_w_r_i_t_e___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::WRITE_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_particle_patches.html">ParticlePatches</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_particle_species.html">ParticleSpecies</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_patch_record.html">PatchRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_patch_record_component.html">PatchRecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_random_dataset_filler.html">RandomDatasetFiller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_read_iterations.html">ReadIterations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading side of the streaming API.  <a href="classopen_p_m_d_1_1_read_iterations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_record.html">Record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_record_component.html">RecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_series.html">Series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root level of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> hierarchy.  <a href="classopen_p_m_d_1_1_series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_series_interface.html">SeriesInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for the root level of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> hierarchy.  <a href="classopen_p_m_d_1_1_series_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_series_iterator.html">SeriesIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_simple_dataset_filler_provider.html">SimpleDatasetFillerProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subset of C++20 std::span class template.  <a href="classopen_p_m_d_1_1_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1unsupported__data__error.html">unsupported_data_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer to mirror structure of logical data and persistent data in file.  <a href="classopen_p_m_d_1_1_writable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_write_iterations.html">WriteIterations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing side of the streaming API.  <a href="classopen_p_m_d_1_1_write_iterations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_written_chunk_info.html">WrittenChunkInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the meta info around a chunk that has been written by some data producing application.  <a href="structopen_p_m_d_1_1_written_chunk_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9d080a50a3cb5d2270b4521f603cea73"><td class="memItemLeft" align="right" valign="top"><a id="a9d080a50a3cb5d2270b4521f603cea73"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_t</b> = <a class="el" href="classopen_p_m_d_1_1_container.html">Container</a>&lt; <a class="el" href="classopen_p_m_d_1_1_iteration.html">Iteration</a>, uint64_t &gt;::iterator</td></tr>
<tr class="separator:a9d080a50a3cb5d2270b4521f603cea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db91901e200bd227ed6311d1dcf22e5"><td class="memItemLeft" align="right" valign="top"><a id="a4db91901e200bd227ed6311d1dcf22e5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Attributable</b> = <a class="el" href="classopen_p_m_d_1_1_attributable_interface.html">AttributableInterface</a></td></tr>
<tr class="separator:a4db91901e200bd227ed6311d1dcf22e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6e81922d905fd3863e665f895f05a1"><td class="memItemLeft" align="right" valign="top"><a id="a3b6e81922d905fd3863e665f895f05a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ChunkTable</b> = std::vector&lt; <a class="el" href="structopen_p_m_d_1_1_written_chunk_info.html">WrittenChunkInfo</a> &gt;</td></tr>
<tr class="separator:a3b6e81922d905fd3863e665f895f05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888344759a4462c331b7d486318d08af"><td class="memItemLeft" align="right" valign="top"><a id="a888344759a4462c331b7d486318d08af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Extent</b> = std::vector&lt; std::uint64_t &gt;</td></tr>
<tr class="separator:a888344759a4462c331b7d486318d08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de848594ce6120f03f2a664577a4619"><td class="memItemLeft" align="right" valign="top"><a id="a2de848594ce6120f03f2a664577a4619"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Offset</b> = std::vector&lt; std::uint64_t &gt;</td></tr>
<tr class="separator:a2de848594ce6120f03f2a664577a4619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465ee2475f7e87a44311bd2e6ff94c4e"><td class="memItemLeft" align="right" valign="top"><a id="a465ee2475f7e87a44311bd2e6ff94c4e"></a>
typedef <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AccessType</b></td></tr>
<tr class="separator:a465ee2475f7e87a44311bd2e6ff94c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b37200bc94d349014460610ce7cf65"><td class="memItemLeft" align="right" valign="top"><a id="ac9b37200bc94d349014460610ce7cf65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SupportedSchema</b> = ADIOS2Schema::SupportedSchema</td></tr>
<tr class="separator:ac9b37200bc94d349014460610ce7cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac04f58bb14b584a3685793e5b29ccd00"><td class="memItemLeft" align="right" valign="top"><a id="ac04f58bb14b584a3685793e5b29ccd00"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> : int { <br />
&#160;&#160;<b>CHAR</b> = LOWEST_DATATYPE, 
<b>UCHAR</b>, 
<b>SHORT</b>, 
<b>INT</b>, 
<br />
&#160;&#160;<b>LONG</b>, 
<b>LONGLONG</b>, 
<b>USHORT</b>, 
<b>UINT</b>, 
<br />
&#160;&#160;<b>ULONG</b>, 
<b>ULONGLONG</b>, 
<b>FLOAT</b>, 
<b>DOUBLE</b>, 
<br />
&#160;&#160;<b>LONG_DOUBLE</b>, 
<b>CFLOAT</b>, 
<b>CDOUBLE</b>, 
<b>CLONG_DOUBLE</b>, 
<br />
&#160;&#160;<b>STRING</b>, 
<b>VEC_CHAR</b>, 
<b>VEC_SHORT</b>, 
<b>VEC_INT</b>, 
<br />
&#160;&#160;<b>VEC_LONG</b>, 
<b>VEC_LONGLONG</b>, 
<b>VEC_UCHAR</b>, 
<b>VEC_USHORT</b>, 
<br />
&#160;&#160;<b>VEC_UINT</b>, 
<b>VEC_ULONG</b>, 
<b>VEC_ULONGLONG</b>, 
<b>VEC_FLOAT</b>, 
<br />
&#160;&#160;<b>VEC_DOUBLE</b>, 
<b>VEC_LONG_DOUBLE</b>, 
<b>VEC_CFLOAT</b>, 
<b>VEC_CDOUBLE</b>, 
<br />
&#160;&#160;<b>VEC_CLONG_DOUBLE</b>, 
<b>VEC_STRING</b>, 
<b>ARR_DBL_7</b>, 
<b>BOOL</b>, 
<br />
&#160;&#160;<b>DATATYPE</b> = HIGHEST_DATATYPE, 
<b>UNDEFINED</b>
<br />
 }</td></tr>
<tr class="memdesc:ac04f58bb14b584a3685793e5b29ccd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete datatype of an object available at runtime. <br /></td></tr>
<tr class="separator:ac04f58bb14b584a3685793e5b29ccd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677be01ff3fa0d48536a70114771d065"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065">FlushLevel</a> : unsigned char { <a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065aff6f10e7003655cf3a02b528b4993a3d">FlushLevel::UserFlush</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065ada1e0af0851f992af15f8837cb34b087">FlushLevel::InternalFlush</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065a2614fd85a8ca09a58c13f4d6a61c6188">FlushLevel::SkeletonOnly</a>
 }</td></tr>
<tr class="memdesc:a677be01ff3fa0d48536a70114771d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine what items should be flushed upon Series::flush()  <a href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065">More...</a><br /></td></tr>
<tr class="separator:a677be01ff3fa0d48536a70114771d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132624db0c6ac134d7a6084ab6d07e1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a> { <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44">Access::READ_ONLY</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1eaa7b843fb734e3b3fea8e5f902d3f4144">Access::READ_WRITE</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1ea294ce20cdefa29be3be0735cb62e715d">Access::CREATE</a>
 }</td></tr>
<tr class="memdesc:a132624db0c6ac134d7a6084ab6d07e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">File access mode to use during IO.  <a href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">More...</a><br /></td></tr>
<tr class="separator:a132624db0c6ac134d7a6084ab6d07e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc2b05c997920a65ff9297e52f3286d"><td class="memItemLeft" align="right" valign="top"><a id="a7dc2b05c997920a65ff9297e52f3286d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> { <br />
&#160;&#160;<b>HDF5</b>, 
<b>ADIOS1</b>, 
<b>ADIOS2</b>, 
<b>ADIOS2_SST</b>, 
<br />
&#160;&#160;<b>ADIOS2_SSC</b>, 
<b>JSON</b>, 
<b>DUMMY</b>
<br />
 }</td></tr>
<tr class="memdesc:a7dc2b05c997920a65ff9297e52f3286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">File format to use during IO. <br /></td></tr>
<tr class="separator:a7dc2b05c997920a65ff9297e52f3286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836aa9398502263fb423787947bf4ff8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">IterationEncoding</a> { <b>fileBased</b>, 
<b>groupBased</b>, 
<b>variableBased</b>
 }</td></tr>
<tr class="memdesc:a836aa9398502263fb423787947bf4ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoding scheme of an Iterations Series'.  <a href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">More...</a><br /></td></tr>
<tr class="separator:a836aa9398502263fb423787947bf4ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f85fd5d90639b5642911697a53183d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a3f85fd5d90639b5642911697a53183d0">AdvanceStatus</a> : unsigned char { <b>OK</b>, 
<b>OVER</b>
 }</td></tr>
<tr class="memdesc:a3f85fd5d90639b5642911697a53183d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">In step-based mode (i.e.  <a href="namespaceopen_p_m_d.html#a3f85fd5d90639b5642911697a53183d0">More...</a><br /></td></tr>
<tr class="separator:a3f85fd5d90639b5642911697a53183d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1549bb191480b2383a8bdc55da639449"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a1549bb191480b2383a8bdc55da639449">AdvanceMode</a> : unsigned char { <b>BEGINSTEP</b>, 
<b>ENDSTEP</b>
 }</td></tr>
<tr class="memdesc:a1549bb191480b2383a8bdc55da639449"><td class="mdescLeft">&#160;</td><td class="mdescRight">In step-based mode (i.e.  <a href="namespaceopen_p_m_d.html#a1549bb191480b2383a8bdc55da639449">More...</a><br /></td></tr>
<tr class="separator:a1549bb191480b2383a8bdc55da639449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f08f98f53b66e47caddfb7e68ab74c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a26f08f98f53b66e47caddfb7e68ab74c">StepStatus</a> : unsigned char { <b>DuringStep</b>, 
<b>NoStep</b>
 }</td></tr>
<tr class="memdesc:a26f08f98f53b66e47caddfb7e68ab74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in step-based mode (i.e.  <a href="namespaceopen_p_m_d.html#a26f08f98f53b66e47caddfb7e68ab74c">More...</a><br /></td></tr>
<tr class="separator:a26f08f98f53b66e47caddfb7e68ab74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd35872ff3aaacc1ec2700443d89c40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40">UnitDimension</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40ad20caec3b48a1eef164cb4ca81ba2587">UnitDimension::L</a> = 0, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40a69691c7bdcc3ce6d5d8a1361f22d04ac">UnitDimension::M</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40ab9ece18c950afbfa6b0fdbfa4ff731d3">UnitDimension::T</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40add7536794b63bf90eccfd37f9b147d7f">UnitDimension::I</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40a61a74be60d291cc4678ab46cc1cdaf91">UnitDimension::theta</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40a8d9c307cb7f3c4a32822a51922d1ceaa">UnitDimension::N</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40aff44570aca8241914870afbc310cdb85">UnitDimension::J</a>
<br />
 }</td></tr>
<tr class="memdesc:a5bd35872ff3aaacc1ec2700443d89c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical dimension of a record.  <a href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40">More...</a><br /></td></tr>
<tr class="separator:a5bd35872ff3aaacc1ec2700443d89c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af20bc44de60df72da1efc5063b8bc87c"><td class="memItemLeft" align="right" valign="top"><a id="af20bc44de60df72da1efc5063b8bc87c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>warnWrongDtype</b> (std::string const &amp;key, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> store, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> request)</td></tr>
<tr class="separator:af20bc44de60df72da1efc5063b8bc87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f65f2fbb62d1792cc286ef9946b72d"><td class="memItemLeft" align="right" valign="top"><a id="a55f65f2fbb62d1792cc286ef9946b72d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const &amp;d)</td></tr>
<tr class="separator:a55f65f2fbb62d1792cc286ef9946b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa1009d5cb668e87c84fe1b923c9f97"><td class="memItemLeft" align="right" valign="top"><a id="a5aa1009d5cb668e87c84fe1b923c9f97"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stringToDatatype</b> (std::string s)</td></tr>
<tr class="separator:a5aa1009d5cb668e87c84fe1b923c9f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75707f4bc429660e9734e8374ce79d23"><td class="memItemLeft" align="right" valign="top"><a id="a75707f4bc429660e9734e8374ce79d23"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>datatypeToString</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> dt)</td></tr>
<tr class="separator:a75707f4bc429660e9734e8374ce79d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed98a0d6afbbfda7c19c6917fc7ab411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aed98a0d6afbbfda7c19c6917fc7ab411">basicDatatype</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt)</td></tr>
<tr class="memdesc:aed98a0d6afbbfda7c19c6917fc7ab411"><td class="mdescLeft">&#160;</td><td class="mdescRight">basicDatatype Strip <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> Datatype of std::vector, std::array et.  <a href="namespaceopen_p_m_d.html#aed98a0d6afbbfda7c19c6917fc7ab411">More...</a><br /></td></tr>
<tr class="separator:aed98a0d6afbbfda7c19c6917fc7ab411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1fe8002d4358804bd49be7a326922e"><td class="memItemLeft" align="right" valign="top"><a id="abb1fe8002d4358804bd49be7a326922e"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toVectorType</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt)</td></tr>
<tr class="separator:abb1fe8002d4358804bd49be7a326922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae7debe2cfe5e72fa62c26e265da442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#adae7debe2cfe5e72fa62c26e265da442">determineFormat</a> (std::string const  &amp;filename)</td></tr>
<tr class="memdesc:adae7debe2cfe5e72fa62c26e265da442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the storage format of a <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy.">Series</a> from the used filename extension.  <a href="namespaceopen_p_m_d.html#adae7debe2cfe5e72fa62c26e265da442">More...</a><br /></td></tr>
<tr class="separator:adae7debe2cfe5e72fa62c26e265da442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85ac121e561aace5e433173de458068"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ae85ac121e561aace5e433173de458068">suffix</a> (<a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> f)</td></tr>
<tr class="memdesc:ae85ac121e561aace5e433173de458068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the default filename suffix for a given storage format.  <a href="namespaceopen_p_m_d.html#ae85ac121e561aace5e433173de458068">More...</a><br /></td></tr>
<tr class="separator:ae85ac121e561aace5e433173de458068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e4024a1d024518745994b4ba0a7522"><td class="memItemLeft" align="right" valign="top"><a id="a47e4024a1d024518745994b4ba0a7522"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a47e4024a1d024518745994b4ba0a7522"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createIOHandler&lt; nlohmann::json &gt;</b> (std::string path, <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a> access, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> format, MPI_Comm comm, nlohmann::json options)</td></tr>
<tr class="separator:a47e4024a1d024518745994b4ba0a7522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae575f571e1ac07f8f58a07ea5a46a562"><td class="memItemLeft" align="right" valign="top"><a id="ae575f571e1ac07f8f58a07ea5a46a562"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae575f571e1ac07f8f58a07ea5a46a562"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createIOHandler&lt; nlohmann::json &gt;</b> (std::string path, <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a> access, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> format, nlohmann::json options)</td></tr>
<tr class="separator:ae575f571e1ac07f8f58a07ea5a46a562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4903b80fed2c996f06a42b8ce6bbc4e"><td class="memItemLeft" align="right" valign="top"><a id="ab4903b80fed2c996f06a42b8ce6bbc4e"></a>
std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createIOHandler</b> (std::string path, <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a> access, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> format)</td></tr>
<tr class="separator:ab4903b80fed2c996f06a42b8ce6bbc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14c9795d8ed440c83c7245e587aca43"><td class="memItemLeft" align="right" valign="top"><a id="ab14c9795d8ed440c83c7245e587aca43"></a>
<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getWritable</b> (<a class="el" href="classopen_p_m_d_1_1_attributable_interface.html">AttributableInterface</a> *a)</td></tr>
<tr class="separator:ab14c9795d8ed440c83c7245e587aca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302b24b95911d3524d0539cf71bcac0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9302b24b95911d3524d0539cf71bcac0"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a9302b24b95911d3524d0539cf71bcac0">getCast</a> (<a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a> const &amp;a)</td></tr>
<tr class="memdesc:a9302b24b95911d3524d0539cf71bcac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a stored specific <a class="el" href="classopen_p_m_d_1_1_attribute.html" title="Varidic datatype supporting at least all formats for attributes specified in the openPMD standard.">Attribute</a> and cast if convertible.  <a href="namespaceopen_p_m_d.html#a9302b24b95911d3524d0539cf71bcac0">More...</a><br /></td></tr>
<tr class="separator:a9302b24b95911d3524d0539cf71bcac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0acf8ce265548d95417e8fbb0e85e88"><td class="memItemLeft" align="right" valign="top"><a id="ac0acf8ce265548d95417e8fbb0e85e88"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dtype_from_numpy</b> (pybind11::dtype const dt)</td></tr>
<tr class="separator:ac0acf8ce265548d95417e8fbb0e85e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8e0b5f39fece9dd2b1e188d897261b"><td class="memItemLeft" align="right" valign="top"><a id="abc8e0b5f39fece9dd2b1e188d897261b"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#abc8e0b5f39fece9dd2b1e188d897261b">dtype_from_bufferformat</a> (std::string const &amp;fmt)</td></tr>
<tr class="memdesc:abc8e0b5f39fece9dd2b1e188d897261b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00" title="Concrete datatype of an object available at runtime.">openPMD::Datatype</a> from py::buffer_info::format. <br /></td></tr>
<tr class="separator:abc8e0b5f39fece9dd2b1e188d897261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ccdac508e96668e0335bb09ae72dd7"><td class="memItemLeft" align="right" valign="top"><a id="a81ccdac508e96668e0335bb09ae72dd7"></a>
pybind11::dtype&#160;</td><td class="memItemRight" valign="bottom"><b>dtype_to_numpy</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> const dt)</td></tr>
<tr class="separator:a81ccdac508e96668e0335bb09ae72dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596f7d1cc2cd0322959b9bd72ae4165d"><td class="memTemplParams" colspan="2">template&lt;typename... T_Args, typename T_SeriesAccessor &gt; </td></tr>
<tr class="memitem:a596f7d1cc2cd0322959b9bd72ae4165d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a596f7d1cc2cd0322959b9bd72ae4165d">add_pickle</a> (pybind11::class_&lt; T_Args... &gt; &amp;cl, T_SeriesAccessor &amp;&amp;seriesAccessor)</td></tr>
<tr class="memdesc:a596f7d1cc2cd0322959b9bd72ae4165d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to Pickle Attributable Classes.  <a href="namespaceopen_p_m_d.html#a596f7d1cc2cd0322959b9bd72ae4165d">More...</a><br /></td></tr>
<tr class="separator:a596f7d1cc2cd0322959b9bd72ae4165d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db4fae7355c770387ebdaf10a8377e1"><td class="memTemplParams" colspan="2"><a id="a1db4fae7355c770387ebdaf10a8377e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1db4fae7355c770387ebdaf10a8377e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determineDatatype</b> ()</td></tr>
<tr class="separator:a1db4fae7355c770387ebdaf10a8377e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3edf432aecf548dfbed9f40796c2882"><td class="memTemplParams" colspan="2"><a id="af3edf432aecf548dfbed9f40796c2882"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3edf432aecf548dfbed9f40796c2882"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determineDatatype</b> (std::shared_ptr&lt; T &gt;)</td></tr>
<tr class="separator:af3edf432aecf548dfbed9f40796c2882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b670ad71d6e80073a7d8fb689b1fd4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a9b670ad71d6e80073a7d8fb689b1fd4a">toBytes</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a9b670ad71d6e80073a7d8fb689b1fd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes representing a Datatype.  <a href="namespaceopen_p_m_d.html#a9b670ad71d6e80073a7d8fb689b1fd4a">More...</a><br /></td></tr>
<tr class="separator:a9b670ad71d6e80073a7d8fb689b1fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ccc9b338d37af8c6bbbcf4f53dfeee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a31ccc9b338d37af8c6bbbcf4f53dfeee">toBits</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a31ccc9b338d37af8c6bbbcf4f53dfeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bits representing a Datatype.  <a href="namespaceopen_p_m_d.html#a31ccc9b338d37af8c6bbbcf4f53dfeee">More...</a><br /></td></tr>
<tr class="separator:a31ccc9b338d37af8c6bbbcf4f53dfeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba5e10b9852d6f900b1998d974fef04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a1ba5e10b9852d6f900b1998d974fef04">isVector</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a1ba5e10b9852d6f900b1998d974fef04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is a vector type.  <a href="namespaceopen_p_m_d.html#a1ba5e10b9852d6f900b1998d974fef04">More...</a><br /></td></tr>
<tr class="separator:a1ba5e10b9852d6f900b1998d974fef04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e4ef028c30b981759878dcf3202a75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a86e4ef028c30b981759878dcf3202a75">isFloatingPoint</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a86e4ef028c30b981759878dcf3202a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is a floating point type.  <a href="namespaceopen_p_m_d.html#a86e4ef028c30b981759878dcf3202a75">More...</a><br /></td></tr>
<tr class="separator:a86e4ef028c30b981759878dcf3202a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6053fa8fcb7ac587c09a3e55eccb38a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a6053fa8fcb7ac587c09a3e55eccb38a7">isComplexFloatingPoint</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a6053fa8fcb7ac587c09a3e55eccb38a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is a complex floating point type.  <a href="namespaceopen_p_m_d.html#a6053fa8fcb7ac587c09a3e55eccb38a7">More...</a><br /></td></tr>
<tr class="separator:a6053fa8fcb7ac587c09a3e55eccb38a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a6326cd3db5c72ce757d0fdc4fd30d21d">isFloatingPoint</a> ()</td></tr>
<tr class="memdesc:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a type is a floating point type.  <a href="namespaceopen_p_m_d.html#a6326cd3db5c72ce757d0fdc4fd30d21d">More...</a><br /></td></tr>
<tr class="separator:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd895ed7c642b854e6acf893ed8b7a6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd895ed7c642b854e6acf893ed8b7a6e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#abd895ed7c642b854e6acf893ed8b7a6e">isComplexFloatingPoint</a> ()</td></tr>
<tr class="memdesc:abd895ed7c642b854e6acf893ed8b7a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a type is a complex floating point type.  <a href="namespaceopen_p_m_d.html#abd895ed7c642b854e6acf893ed8b7a6e">More...</a><br /></td></tr>
<tr class="separator:abd895ed7c642b854e6acf893ed8b7a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf606f8f4e4e97426f3dd4e3d662ff"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a17bf606f8f4e4e97426f3dd4e3d662ff">isInteger</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a17bf606f8f4e4e97426f3dd4e3d662ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is an integer type.  <a href="namespaceopen_p_m_d.html#a17bf606f8f4e4e97426f3dd4e3d662ff">More...</a><br /></td></tr>
<tr class="separator:a17bf606f8f4e4e97426f3dd4e3d662ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122aded2200302833a428f731a8841df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a122aded2200302833a428f731a8841df"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a122aded2200302833a428f731a8841df">isInteger</a> ()</td></tr>
<tr class="memdesc:a122aded2200302833a428f731a8841df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a type is an integer type.  <a href="namespaceopen_p_m_d.html#a122aded2200302833a428f731a8841df">More...</a><br /></td></tr>
<tr class="separator:a122aded2200302833a428f731a8841df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="memTemplParams" colspan="2">template&lt;typename T_FP &gt; </td></tr>
<tr class="memitem:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a1e0c5a7cd758d4f0e2495639da8496a3">isSameFloatingPoint</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is equivalent to a floating point type.  <a href="namespaceopen_p_m_d.html#a1e0c5a7cd758d4f0e2495639da8496a3">More...</a><br /></td></tr>
<tr class="separator:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d77cb0d3393504e417aea6ad1ae9a58"><td class="memTemplParams" colspan="2">template&lt;typename T_CFP &gt; </td></tr>
<tr class="memitem:a2d77cb0d3393504e417aea6ad1ae9a58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a2d77cb0d3393504e417aea6ad1ae9a58">isSameComplexFloatingPoint</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a2d77cb0d3393504e417aea6ad1ae9a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is equivalent to a complex floating point type.  <a href="namespaceopen_p_m_d.html#a2d77cb0d3393504e417aea6ad1ae9a58">More...</a><br /></td></tr>
<tr class="separator:a2d77cb0d3393504e417aea6ad1ae9a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="memTemplParams" colspan="2">template&lt;typename T_Int &gt; </td></tr>
<tr class="memitem:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aae1011a1acfc03c4914f0a6e2d3443a9">isSameInteger</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is equivalent to an integer type.  <a href="namespaceopen_p_m_d.html#aae1011a1acfc03c4914f0a6e2d3443a9">More...</a><br /></td></tr>
<tr class="separator:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97abc0c52f6828a3ce8f8a01bdd4a9fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a97abc0c52f6828a3ce8f8a01bdd4a9fe">isSame</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const d, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const e)</td></tr>
<tr class="memdesc:a97abc0c52f6828a3ce8f8a01bdd4a9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for two Datatypes.  <a href="namespaceopen_p_m_d.html#a97abc0c52f6828a3ce8f8a01bdd4a9fe">More...</a><br /></td></tr>
<tr class="separator:a97abc0c52f6828a3ce8f8a01bdd4a9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db326966214149dc4fcdadd22fd7787"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a0db326966214149dc4fcdadd22fd7787"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a0db326966214149dc4fcdadd22fd7787">switchType</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt, Action action, Args &amp;&amp;... args) -&gt; decltype(action. template operator()&lt; char &gt;(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a0db326966214149dc4fcdadd22fd7787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype.  <a href="namespaceopen_p_m_d.html#a0db326966214149dc4fcdadd22fd7787">More...</a><br /></td></tr>
<tr class="separator:a0db326966214149dc4fcdadd22fd7787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e7a2622042be450c9ea61831bc376e"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a18e7a2622042be450c9ea61831bc376e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a18e7a2622042be450c9ea61831bc376e">switchNonVectorType</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt, Action action, Args &amp;&amp;... args) -&gt; decltype(action. template operator()&lt; char &gt;(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a18e7a2622042be450c9ea61831bc376e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype.  <a href="namespaceopen_p_m_d.html#a18e7a2622042be450c9ea61831bc376e">More...</a><br /></td></tr>
<tr class="separator:a18e7a2622042be450c9ea61831bc376e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae40b97bccc80a77bea9d684aba52cc"><td class="memTemplParams" colspan="2">template&lt;typename JSON &gt; </td></tr>
<tr class="memitem:a0ae40b97bccc80a77bea9d684aba52cc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a0ae40b97bccc80a77bea9d684aba52cc">createIOHandler</a> (std::string path, <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a> access, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> format, MPI_Comm comm, JSON options)</td></tr>
<tr class="memdesc:a0ae40b97bccc80a77bea9d684aba52cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an appropriate specific IOHandler for the desired IO mode that may be MPI-aware.  <a href="namespaceopen_p_m_d.html#a0ae40b97bccc80a77bea9d684aba52cc">More...</a><br /></td></tr>
<tr class="separator:a0ae40b97bccc80a77bea9d684aba52cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0c51d097c915626ef8a30a217b47a2"><td class="memTemplParams" colspan="2">template&lt;typename JSON &gt; </td></tr>
<tr class="memitem:a3a0c51d097c915626ef8a30a217b47a2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a3a0c51d097c915626ef8a30a217b47a2">createIOHandler</a> (std::string path, <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a> access, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> format, JSON options=JSON())</td></tr>
<tr class="memdesc:a3a0c51d097c915626ef8a30a217b47a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an appropriate specific IOHandler for the desired IO mode.  <a href="namespaceopen_p_m_d.html#a3a0c51d097c915626ef8a30a217b47a2">More...</a><br /></td></tr>
<tr class="separator:a3a0c51d097c915626ef8a30a217b47a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb09589bae9322698f52d7b154ecb3cc"><td class="memItemLeft" align="right" valign="top"><a id="adb09589bae9322698f52d7b154ecb3cc"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getBP1Extent</b> (Extent const &amp;e, std::string const &amp;delimiter=&quot;,&quot;)</td></tr>
<tr class="separator:adb09589bae9322698f52d7b154ecb3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e737b753dd80f3eb1c5822a2f5a63a5"><td class="memItemLeft" align="right" valign="top"><a id="a2e737b753dd80f3eb1c5822a2f5a63a5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getZerosLikeBP1Extent</b> (Extent const &amp;e, std::string const &amp;delimiter=&quot;,&quot;)</td></tr>
<tr class="separator:a2e737b753dd80f3eb1c5822a2f5a63a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bbaca4627cc9cfcbab78e18fd7bbde"><td class="memItemLeft" align="right" valign="top"><a id="aa4bbaca4627cc9cfcbab78e18fd7bbde"></a>
ADIOS_DATATYPES&#160;</td><td class="memItemRight" valign="bottom"><b>getBP1DataType</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dtype)</td></tr>
<tr class="separator:aa4bbaca4627cc9cfcbab78e18fd7bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32c080169685fa169a06aafbc23aadb"><td class="memItemLeft" align="right" valign="top"><a id="ad32c080169685fa169a06aafbc23aadb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>concrete_bp1_file_position</b> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *w)</td></tr>
<tr class="separator:ad32c080169685fa169a06aafbc23aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b1a1f1944dbc9db5c83d53c667cede"><td class="memItemLeft" align="right" valign="top"><a id="a36b1a1f1944dbc9db5c83d53c667cede"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getEnvNum</b> (std::string const &amp;key, std::string const &amp;defaultValue)</td></tr>
<tr class="separator:a36b1a1f1944dbc9db5c83d53c667cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d28f48bf5c1b808c96133fea83f68b7"><td class="memTemplParams" colspan="2"><a id="a7d28f48bf5c1b808c96133fea83f68b7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d28f48bf5c1b808c96133fea83f68b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readVectorAttributeInternal</b> (void *data, int size)</td></tr>
<tr class="separator:a7d28f48bf5c1b808c96133fea83f68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3b166f64d52fe0b3507c3f22b02ace"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:aeb3b166f64d52fe0b3507c3f22b02ace"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aeb3b166f64d52fe0b3507c3f22b02ace">switchAdios2AttributeType</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt, Action action, Args &amp;&amp;... args) -&gt; decltype(action. template operator()&lt; char &gt;(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:aeb3b166f64d52fe0b3507c3f22b02ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype.  <a href="namespaceopen_p_m_d.html#aeb3b166f64d52fe0b3507c3f22b02ace">More...</a><br /></td></tr>
<tr class="separator:aeb3b166f64d52fe0b3507c3f22b02ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d0fc89006b5f46f885126cf3a971c5"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a66d0fc89006b5f46f885126cf3a971c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a66d0fc89006b5f46f885126cf3a971c5">switchAdios2VariableType</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt, Action action, Args &amp;&amp;... args) -&gt; decltype(action. template operator()&lt; char &gt;(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a66d0fc89006b5f46f885126cf3a971c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype.  <a href="namespaceopen_p_m_d.html#a66d0fc89006b5f46f885126cf3a971c5">More...</a><br /></td></tr>
<tr class="separator:a66d0fc89006b5f46f885126cf3a971c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add284089e173436073305642d4312c94"><td class="memItemLeft" align="right" valign="top"><a id="add284089e173436073305642d4312c94"></a>
hid_t&#160;</td><td class="memItemRight" valign="bottom"><b>getH5DataSpace</b> (<a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a> const &amp;att)</td></tr>
<tr class="separator:add284089e173436073305642d4312c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1858f75fc1ed5f79bda91afeaac81ab1"><td class="memItemLeft" align="right" valign="top"><a id="a1858f75fc1ed5f79bda91afeaac81ab1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>concrete_h5_file_position</b> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *w)</td></tr>
<tr class="separator:a1858f75fc1ed5f79bda91afeaac81ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226061d28a7dd45c4a2785d49716595f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; hsize_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a226061d28a7dd45c4a2785d49716595f">getOptimalChunkDims</a> (std::vector&lt; hsize_t &gt; const dims, size_t const typeSize)</td></tr>
<tr class="memdesc:a226061d28a7dd45c4a2785d49716595f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the chunk dimensions for a dataset.  <a href="namespaceopen_p_m_d.html#a226061d28a7dd45c4a2785d49716595f">More...</a><br /></td></tr>
<tr class="separator:a226061d28a7dd45c4a2785d49716595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6750b56f2fc2b3316f8dd95db64e31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aeb6750b56f2fc2b3316f8dd95db64e31">OPENPMDAPI_EXPORT_ENUM_CLASS</a> (Operation)</td></tr>
<tr class="memdesc:aeb6750b56f2fc2b3316f8dd95db64e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of IO operation between logical and persistent data.  <a href="namespaceopen_p_m_d.html#aeb6750b56f2fc2b3316f8dd95db64e31">More...</a><br /></td></tr>
<tr class="separator:aeb6750b56f2fc2b3316f8dd95db64e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5064c76f963a45e0ed2d3796e7a35b"><td class="memItemLeft" align="right" valign="top"><a id="aaa5064c76f963a45e0ed2d3796e7a35b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">openPMD::IterationEncoding</a> const &amp;)</td></tr>
<tr class="separator:aaa5064c76f963a45e0ed2d3796e7a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77c87539e6b53bef7d3afb70347c076"><td class="memItemLeft" align="right" valign="top"><a id="af77c87539e6b53bef7d3afb70347c076"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="classopen_p_m_d_1_1_mesh.html#acee3512164b9df9b3549bac0aa782383">openPMD::Mesh::Geometry</a> const &amp;)</td></tr>
<tr class="separator:af77c87539e6b53bef7d3afb70347c076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8fe26a6fd94fced4f5e493eee1486"><td class="memItemLeft" align="right" valign="top"><a id="a8bb8fe26a6fd94fced4f5e493eee1486"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="classopen_p_m_d_1_1_mesh.html#af28bf48368071545c77bb981b8c89009">openPMD::Mesh::DataOrder</a> const &amp;)</td></tr>
<tr class="separator:a8bb8fe26a6fd94fced4f5e493eee1486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684c17f1fdd0f9d04e1a92aa0efc52cf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a684c17f1fdd0f9d04e1a92aa0efc52cf">getVersion</a> ()</td></tr>
<tr class="memdesc:a684c17f1fdd0f9d04e1a92aa0efc52cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version of the openPMD-api library (run-time)  <a href="namespaceopen_p_m_d.html#a684c17f1fdd0f9d04e1a92aa0efc52cf">More...</a><br /></td></tr>
<tr class="separator:a684c17f1fdd0f9d04e1a92aa0efc52cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f8b29a6c7b24f34c2383080bc325bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#af3f8b29a6c7b24f34c2383080bc325bc">getStandard</a> ()</td></tr>
<tr class="memdesc:af3f8b29a6c7b24f34c2383080bc325bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> standard (read &amp; write, run-time)  <a href="namespaceopen_p_m_d.html#af3f8b29a6c7b24f34c2383080bc325bc">More...</a><br /></td></tr>
<tr class="separator:af3f8b29a6c7b24f34c2383080bc325bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa97da38a96cab56c67724443cf6378"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#acfa97da38a96cab56c67724443cf6378">getStandardMinimum</a> ()</td></tr>
<tr class="memdesc:acfa97da38a96cab56c67724443cf6378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> standard (read, run-time)  <a href="namespaceopen_p_m_d.html#acfa97da38a96cab56c67724443cf6378">More...</a><br /></td></tr>
<tr class="separator:acfa97da38a96cab56c67724443cf6378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad291085916d366b26abe1c66ac6504e5"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ad291085916d366b26abe1c66ac6504e5">getVariants</a> ()</td></tr>
<tr class="memdesc:ad291085916d366b26abe1c66ac6504e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the feature variants of the openPMD-api library (run-time)  <a href="namespaceopen_p_m_d.html#ad291085916d366b26abe1c66ac6504e5">More...</a><br /></td></tr>
<tr class="separator:ad291085916d366b26abe1c66ac6504e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8176cb8239cebea4ec25cf4230fecc1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ae8176cb8239cebea4ec25cf4230fecc1">getFileExtensions</a> ()</td></tr>
<tr class="memdesc:ae8176cb8239cebea4ec25cf4230fecc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file extensions supported in this variant of the openPMD-api library (run-time)  <a href="namespaceopen_p_m_d.html#ae8176cb8239cebea4ec25cf4230fecc1">More...</a><br /></td></tr>
<tr class="separator:ae8176cb8239cebea4ec25cf4230fecc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a276c2fa9e763d9c53ae30f3cadf3d317"><td class="memItemLeft" align="right" valign="top"><a id="a276c2fa9e763d9c53ae30f3cadf3d317"></a>
std::vector&lt; <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a276c2fa9e763d9c53ae30f3cadf3d317">openPMD_Datatypes</a></td></tr>
<tr class="memdesc:a276c2fa9e763d9c53ae30f3cadf3d317"><td class="mdescLeft">&#160;</td><td class="mdescRight">All <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatypes defined in Datatype, listed in order in a vector. <br /></td></tr>
<tr class="separator:a276c2fa9e763d9c53ae30f3cadf3d317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778f7de8a97c6b6f88909cf877193f5"><td class="memItemLeft" align="right" valign="top"><a id="a8778f7de8a97c6b6f88909cf877193f5"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>LOWEST_DATATYPE</b> = 0</td></tr>
<tr class="separator:a8778f7de8a97c6b6f88909cf877193f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd28ac22c74f0d20dacaad4a78aa1f9"><td class="memItemLeft" align="right" valign="top"><a id="aabd28ac22c74f0d20dacaad4a78aa1f9"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>HIGHEST_DATATYPE</b> = 1000</td></tr>
<tr class="separator:aabd28ac22c74f0d20dacaad4a78aa1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c4097de4d816dc05b963bf181abeef"><td class="memTemplParams" colspan="2"><a id="ad5c4097de4d816dc05b963bf181abeef"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad5c4097de4d816dc05b963bf181abeef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>decay_equiv_v</b> = <a class="el" href="structopen_p_m_d_1_1decay__equiv.html">decay_equiv</a>&lt; T, U &gt;::value</td></tr>
<tr class="separator:ad5c4097de4d816dc05b963bf181abeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb809586a5f749c40c036c7514c6f11"><td class="memItemLeft" align="right" valign="top"><a id="abfb809586a5f749c40c036c7514c6f11"></a>
class OPENPMDAPI_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>ADIOS1IOHandlerImpl</b></td></tr>
<tr class="separator:abfb809586a5f749c40c036c7514c6f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f01d219d9554af96efd41b9a2dc753"><td class="memItemLeft" align="right" valign="top"><a id="ae2f01d219d9554af96efd41b9a2dc753"></a>
class OPENPMDAPI_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>ParallelADIOS1IOHandlerImpl</b></td></tr>
<tr class="separator:ae2f01d219d9554af96efd41b9a2dc753"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public definitions of openPMD-api. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a132624db0c6ac134d7a6084ab6d07e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132624db0c6ac134d7a6084ab6d07e1e">&#9670;&nbsp;</a></span>Access</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">openPMD::Access</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structopen_p_m_d_1_1_file.html">File</a> access mode to use during IO. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a132624db0c6ac134d7a6084ab6d07e1ea47c7e7cb36a953a8c47e02000036bb44"></a>READ_ONLY&#160;</td><td class="fielddoc"><p>open series as read-only, fails if series is not found </p>
</td></tr>
<tr><td class="fieldname"><a id="a132624db0c6ac134d7a6084ab6d07e1eaa7b843fb734e3b3fea8e5f902d3f4144"></a>READ_WRITE&#160;</td><td class="fielddoc"><p>open existing series as writable </p>
</td></tr>
<tr><td class="fieldname"><a id="a132624db0c6ac134d7a6084ab6d07e1ea294ce20cdefa29be3be0735cb62e715d"></a>CREATE&#160;</td><td class="fielddoc"><p>create new series and truncate existing (files) </p>
</td></tr>
</table>

</div>
</div>
<a id="a1549bb191480b2383a8bdc55da639449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1549bb191480b2383a8bdc55da639449">&#9670;&nbsp;</a></span>AdvanceMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a1549bb191480b2383a8bdc55da639449">openPMD::AdvanceMode</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In step-based mode (i.e. </p>
<p>when using the Streaming API), stepping/advancing through the <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy.">Series</a> is performed in terms of interleaving begin- and end-step calls. Distinguish both kinds by using this enum. </p>

</div>
</div>
<a id="a3f85fd5d90639b5642911697a53183d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f85fd5d90639b5642911697a53183d0">&#9670;&nbsp;</a></span>AdvanceStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a3f85fd5d90639b5642911697a53183d0">openPMD::AdvanceStatus</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In step-based mode (i.e. </p>
<p>when using the Streaming API), indicate whether there are further steps to read or not (i.e. the stream is not over or it is). </p>

</div>
</div>
<a id="a677be01ff3fa0d48536a70114771d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677be01ff3fa0d48536a70114771d065">&#9670;&nbsp;</a></span>FlushLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065">openPMD::FlushLevel</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine what items should be flushed upon <a class="el" href="classopen_p_m_d_1_1_series_interface.html#a4cc24ece6880f7075c092d4ab076f7d1" title="Execute all required remaining IO operations to write or read data.">Series::flush()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a677be01ff3fa0d48536a70114771d065aff6f10e7003655cf3a02b528b4993a3d"></a>UserFlush&#160;</td><td class="fielddoc"><p>Flush operation that was triggered by user code. </p>
<p>Everything flushable must be flushed. This mode defines a flush point (see docs/source/usage/workflow.rst.rst). </p>
</td></tr>
<tr><td class="fieldname"><a id="a677be01ff3fa0d48536a70114771d065ada1e0af0851f992af15f8837cb34b087"></a>InternalFlush&#160;</td><td class="fielddoc"><p>Default mode, used when flushes are triggered internally, e.g. </p>
<p>during parsing to read attributes. Does not trigger a flush point. All operations must be performed by a backend, except for those that may only happen at a flush point. Those operations must not be performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a677be01ff3fa0d48536a70114771d065a2614fd85a8ca09a58c13f4d6a61c6188"></a>SkeletonOnly&#160;</td><td class="fielddoc"><p>Restricted mode, ensures to set up the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> hierarchy (as far as defined so far) in the backend. </p>
<p>Do not flush record components / datasets, especially do not flush CREATE_DATASET tasks. Attributes may or may not be flushed yet. </p>
</td></tr>
</table>

</div>
</div>
<a id="a836aa9398502263fb423787947bf4ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836aa9398502263fb423787947bf4ff8">&#9670;&nbsp;</a></span>IterationEncoding</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">openPMD::IterationEncoding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encoding scheme of an Iterations <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy.">Series</a>'. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/openPMD/openPMD-standard/blob/latest/STANDARD.md#iterations-and-time-series">https://github.com/openPMD/openPMD-standard/blob/latest/STANDARD.md#iterations-and-time-series</a> </dd></dl>

</div>
</div>
<a id="a26f08f98f53b66e47caddfb7e68ab74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f08f98f53b66e47caddfb7e68ab74c">&#9670;&nbsp;</a></span>StepStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a26f08f98f53b66e47caddfb7e68ab74c">openPMD::StepStatus</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used in step-based mode (i.e. </p>
<p>when using the Streaming API) to determine whether a step is currently active or not. </p>

</div>
</div>
<a id="a5bd35872ff3aaacc1ec2700443d89c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd35872ff3aaacc1ec2700443d89c40">&#9670;&nbsp;</a></span>UnitDimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40">openPMD::UnitDimension</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Physical dimension of a record. </p>
<p>Dimensional base quantities of the international system of quantities </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40ad20caec3b48a1eef164cb4ca81ba2587"></a>L&#160;</td><td class="fielddoc"><p>length </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40a69691c7bdcc3ce6d5d8a1361f22d04ac"></a>M&#160;</td><td class="fielddoc"><p>mass </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40ab9ece18c950afbfa6b0fdbfa4ff731d3"></a>T&#160;</td><td class="fielddoc"><p>time </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40add7536794b63bf90eccfd37f9b147d7f"></a>I&#160;</td><td class="fielddoc"><p>electric current </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40a61a74be60d291cc4678ab46cc1cdaf91"></a>theta&#160;</td><td class="fielddoc"><p>thermodynamic temperature </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40a8d9c307cb7f3c4a32822a51922d1ceaa"></a>N&#160;</td><td class="fielddoc"><p>amount of substance </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40aff44570aca8241914870afbc310cdb85"></a>J&#160;</td><td class="fielddoc"><p>luminous intensity </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a596f7d1cc2cd0322959b9bd72ae4165d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596f7d1cc2cd0322959b9bd72ae4165d">&#9670;&nbsp;</a></span>add_pickle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T_Args, typename T_SeriesAccessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openPMD::add_pickle </td>
          <td>(</td>
          <td class="paramtype">pybind11::class_&lt; T_Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_SeriesAccessor &amp;&amp;&#160;</td>
          <td class="paramname"><em>seriesAccessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to Pickle Attributable Classes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_Args</td><td>the types in pybind11::class_ - the first type will be pickled </td></tr>
    <tr><td class="paramname">T_SeriesAccessor</td><td>During unpickle, this accesses the object inside a newly constructed series </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cl</td><td>the pybind11 class that gets the pickle methods defined </td></tr>
    <tr><td class="paramname">seriesAccessor</td><td>accessor from series to object during unpickling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed98a0d6afbbfda7c19c6917fc7ab411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed98a0d6afbbfda7c19c6917fc7ab411">&#9670;&nbsp;</a></span>basicDatatype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> openPMD::basicDatatype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>basicDatatype Strip <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> Datatype of std::vector, std::array et. </p>
<p>al. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The "full" Datatype. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The "inner" Datatype. </dd></dl>

</div>
</div>
<a id="a3a0c51d097c915626ef8a30a217b47a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0c51d097c915626ef8a30a217b47a2">&#9670;&nbsp;</a></span>createIOHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename JSON &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt; openPMD::createIOHandler </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JSON&#160;</td>
          <td class="paramname"><em>options</em> = <code>JSON()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an appropriate specific IOHandler for the desired IO mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to root folder for all operations associated with the desired handler. </td></tr>
    <tr><td class="paramname">access</td><td>Access describing desired operations and permissions of the desired handler. </td></tr>
    <tr><td class="paramname">format</td><td>Format describing the IO backend of the desired handler. </td></tr>
    <tr><td class="paramname">options</td><td>JSON-formatted option string, to be interpreted by the backend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JSON</td><td>Substitute for nlohmann::json. Templated to avoid including nlohmann::json in a .hpp file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to created IOHandler. </dd></dl>

</div>
</div>
<a id="a0ae40b97bccc80a77bea9d684aba52cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae40b97bccc80a77bea9d684aba52cc">&#9670;&nbsp;</a></span>createIOHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename JSON &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt; openPMD::createIOHandler </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a132624db0c6ac134d7a6084ab6d07e1e">Access</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JSON&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an appropriate specific IOHandler for the desired IO mode that may be MPI-aware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to root folder for all operations associated with the desired handler. </td></tr>
    <tr><td class="paramname">access</td><td>Access mode describing desired operations and permissions of the desired handler. </td></tr>
    <tr><td class="paramname">format</td><td>Format describing the IO backend of the desired handler. </td></tr>
    <tr><td class="paramname">comm</td><td>MPI communicator used for IO. </td></tr>
    <tr><td class="paramname">options</td><td>JSON-formatted option string, to be interpreted by the backend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JSON</td><td>Substitute for nlohmann::json. Templated to avoid including nlohmann::json in a .hpp file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to created IOHandler. </dd></dl>

</div>
</div>
<a id="adae7debe2cfe5e72fa62c26e265da442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae7debe2cfe5e72fa62c26e265da442">&#9670;&nbsp;</a></span>determineFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> openPMD::determineFormat </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the storage format of a <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy.">Series</a> from the used filename extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string containing the filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Format that best fits the filename extension. </dd></dl>

</div>
</div>
<a id="a9302b24b95911d3524d0539cf71bcac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9302b24b95911d3524d0539cf71bcac0">&#9670;&nbsp;</a></span>getCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U openPMD::getCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a> const &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a stored specific <a class="el" href="classopen_p_m_d_1_1_attribute.html" title="Varidic datatype supporting at least all formats for attributes specified in the openPMD standard.">Attribute</a> and cast if convertible. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if stored object is not static castable to U. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Type of the object to be casted to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the retrieved object, casted to type U. </dd></dl>

</div>
</div>
<a id="ae8176cb8239cebea4ec25cf4230fecc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8176cb8239cebea4ec25cf4230fecc1">&#9670;&nbsp;</a></span>getFileExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; openPMD::getFileExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the file extensions supported in this variant of the openPMD-api library (run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt; std::string &gt; with file extensions </dd></dl>

</div>
</div>
<a id="a226061d28a7dd45c4a2785d49716595f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226061d28a7dd45c4a2785d49716595f">&#9670;&nbsp;</a></span>getOptimalChunkDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; hsize_t &gt; openPMD::getOptimalChunkDims </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; hsize_t &gt; const&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>typeSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the chunk dimensions for a dataset. </p>
<p>Chunk dimensions are selected to create chunks sizes between 64KByte and 4MB. Smaller chunk sizes are inefficient due to overhead, larger chunks do not map well to file system blocks and striding.</p>
<p>Chunk dimensions are less or equal to dataset dimensions and do not need to be a factor of the respective dataset dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>dimensions of dataset to get chunk dims for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeSize</td><td>size of each element in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array for resulting chunk dimensions </dd></dl>

</div>
</div>
<a id="af3f8b29a6c7b24f34c2383080bc325bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f8b29a6c7b24f34c2383080bc325bc">&#9670;&nbsp;</a></span>getStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::getStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> standard (read &amp; write, run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::string <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> standard version (dot separated) </dd></dl>

</div>
</div>
<a id="acfa97da38a96cab56c67724443cf6378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa97da38a96cab56c67724443cf6378">&#9670;&nbsp;</a></span>getStandardMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::getStandardMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> standard (read, run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::string minimum <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> standard version (dot separated) </dd></dl>

</div>
</div>
<a id="ad291085916d366b26abe1c66ac6504e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad291085916d366b26abe1c66ac6504e5">&#9670;&nbsp;</a></span>getVariants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, bool &gt; openPMD::getVariants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the feature variants of the openPMD-api library (run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt; std::string, bool &gt; with variants such as backends </dd></dl>

</div>
</div>
<a id="a684c17f1fdd0f9d04e1a92aa0efc52cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684c17f1fdd0f9d04e1a92aa0efc52cf">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the version of the openPMD-api library (run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::string API version (dot separated) </dd></dl>

</div>
</div>
<a id="abd895ed7c642b854e6acf893ed8b7a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd895ed7c642b854e6acf893ed8b7a6e">&#9670;&nbsp;</a></span>isComplexFloatingPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isComplexFloatingPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a type is a complex floating point type. </p>
<p>Like isFloatingPoint but for complex floats</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if complex floating point, otherwise false </dd></dl>

</div>
</div>
<a id="a6053fa8fcb7ac587c09a3e55eccb38a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6053fa8fcb7ac587c09a3e55eccb38a7">&#9670;&nbsp;</a></span>isComplexFloatingPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isComplexFloatingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is a complex floating point type. </p>
<p>Includes our vector types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if complex floating point, otherwise false </dd></dl>

</div>
</div>
<a id="a6326cd3db5c72ce757d0fdc4fd30d21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6326cd3db5c72ce757d0fdc4fd30d21d">&#9670;&nbsp;</a></span>isFloatingPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isFloatingPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a type is a floating point type. </p>
<p>Just std::is_floating_point but also valid for std::vector&lt; &gt; types</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if floating point, otherwise false </dd></dl>

</div>
</div>
<a id="a86e4ef028c30b981759878dcf3202a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e4ef028c30b981759878dcf3202a75">&#9670;&nbsp;</a></span>isFloatingPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isFloatingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is a floating point type. </p>
<p>Equivalent to std::is_floating_point including our vector types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if floating point, otherwise false </dd></dl>

</div>
</div>
<a id="a122aded2200302833a428f731a8841df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122aded2200302833a428f731a8841df">&#9670;&nbsp;</a></span>isInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, bool &gt; openPMD::isInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a type is an integer type. </p>
<p>contrary to std::is_integer, the types bool and char types are not considered ints in this function</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;bool, bool&gt; with isInteger and isSigned result </dd></dl>

</div>
</div>
<a id="a17bf606f8f4e4e97426f3dd4e3d662ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf606f8f4e4e97426f3dd4e3d662ff">&#9670;&nbsp;</a></span>isInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, bool &gt; openPMD::isInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is an integer type. </p>
<p>contrary to std::is_integer, the types bool and char types are not considered ints in this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;bool, bool&gt; with isInteger and isSigned result </dd></dl>

</div>
</div>
<a id="a97abc0c52f6828a3ce8f8a01bdd4a9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97abc0c52f6828a3ce8f8a01bdd4a9fe">&#9670;&nbsp;</a></span>isSame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isSame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison for two Datatypes. </p>
<p>Besides returning true for the same types, identical implementations on some platforms, e.g. if long and long long are the same or double and long double will also return true. </p>

</div>
</div>
<a id="a2d77cb0d3393504e417aea6ad1ae9a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d77cb0d3393504e417aea6ad1ae9a58">&#9670;&nbsp;</a></span>isSameComplexFloatingPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CFP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isSameComplexFloatingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is equivalent to a complex floating point type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_CFP</td><td>complex floating point type to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both types are complex floating point and same bitness, else false </dd></dl>

</div>
</div>
<a id="a1e0c5a7cd758d4f0e2495639da8496a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0c5a7cd758d4f0e2495639da8496a3">&#9670;&nbsp;</a></span>isSameFloatingPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_FP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isSameFloatingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is equivalent to a floating point type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_FP</td><td>floating point type to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both types are floating point and same bitness, else false </dd></dl>

</div>
</div>
<a id="aae1011a1acfc03c4914f0a6e2d3443a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1011a1acfc03c4914f0a6e2d3443a9">&#9670;&nbsp;</a></span>isSameInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isSameInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is equivalent to an integer type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_Int</td><td>signed or unsigned integer type to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both types are integers, same signed and same bitness, else false </dd></dl>

</div>
</div>
<a id="a1ba5e10b9852d6f900b1998d974fef04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba5e10b9852d6f900b1998d974fef04">&#9670;&nbsp;</a></span>isVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is a vector type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if vector type, else false </dd></dl>

</div>
</div>
<a id="aeb6750b56f2fc2b3316f8dd95db64e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6750b56f2fc2b3316f8dd95db64e31">&#9670;&nbsp;</a></span>OPENPMDAPI_EXPORT_ENUM_CLASS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">openPMD::OPENPMDAPI_EXPORT_ENUM_CLASS </td>
          <td>(</td>
          <td class="paramtype">Operation&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of IO operation between logical and persistent data. </p>
<p>&lt; Query chunks that can be loaded in a dataset</p>

</div>
</div>
<a id="ae1a884049992feb89041c2e3f34e25cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a884049992feb89041c2e3f34e25cb">&#9670;&nbsp;</a></span>shareRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; openPMD::shareRaw </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share ownership with a raw pointer. </p>
<p>Helper function to share load/store data ownership unprotected and without reference counting with a raw pointer or stdlib container (that implements a contiguous data storage).</p>
<dl class="section warning"><dt>Warning</dt><dd>this is a helper function to bypass the shared-pointer API for storing data behind raw pointers. Using it puts the responsibility of buffer-consistency between stores and flushes to the users side without an indication via reference counting. </dd></dl>

</div>
</div>
<a id="ae85ac121e561aace5e433173de458068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85ac121e561aace5e433173de458068">&#9670;&nbsp;</a></span>suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the default filename suffix for a given storage format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td><a class="el" href="structopen_p_m_d_1_1_file.html">File</a> format to determine suffix for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the default filename suffix </dd></dl>

</div>
</div>
<a id="aeb3b166f64d52fe0b3507c3f22b02ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3b166f64d52fe0b3507c3f22b02ace">&#9670;&nbsp;</a></span>switchAdios2AttributeType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto openPMD::switchAdios2AttributeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
        action. template operator () &lt; char &gt;
        ( std::forward&lt; Args &gt;( args )... ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </p>
<p>Will call the functor passed to it using the C++ internal datatype corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype as template parameter for the templated &lt;operator()&gt;(). Considers only types that are eligible for an ADIOS2 attribute.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>The functor's return type. </td></tr>
    <tr><td class="paramname">Action</td><td>The functor's type. </td></tr>
    <tr><td class="paramname">Args</td><td>The functors argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </td></tr>
    <tr><td class="paramname">action</td><td>The functor. </td></tr>
    <tr><td class="paramname">args</td><td>The functor's arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functor, when calling its &lt;operator()&gt;() with the passed arguments and the template parameter type corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> type. </dd></dl>

</div>
</div>
<a id="a66d0fc89006b5f46f885126cf3a971c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d0fc89006b5f46f885126cf3a971c5">&#9670;&nbsp;</a></span>switchAdios2VariableType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto openPMD::switchAdios2VariableType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
        action. template operator () &lt; char &gt;
        ( std::forward&lt; Args &gt;( args )... ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </p>
<p>Will call the functor passed to it using the C++ internal datatype corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype as template parameter for the templated &lt;operator()&gt;(). Considers only types that are eligible for an ADIOS2 variable (excluding STRING. Use <a class="el" href="namespaceopen_p_m_d.html#aeb3b166f64d52fe0b3507c3f22b02ace" title="Generalizes switching over an openPMD datatype.">switchAdios2AttributeType()</a> for that).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>The functor's return type. </td></tr>
    <tr><td class="paramname">Action</td><td>The functor's type. </td></tr>
    <tr><td class="paramname">Args</td><td>The functors argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </td></tr>
    <tr><td class="paramname">action</td><td>The functor. </td></tr>
    <tr><td class="paramname">args</td><td>The functor's arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functor, when calling its &lt;operator()&gt;() with the passed arguments and the template parameter type corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> type. </dd></dl>

</div>
</div>
<a id="a18e7a2622042be450c9ea61831bc376e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e7a2622042be450c9ea61831bc376e">&#9670;&nbsp;</a></span>switchNonVectorType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto openPMD::switchNonVectorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
        action. template operator () &lt; char &gt;
        ( std::forward&lt; Args &gt;( args )... ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </p>
<p>Will call the functor passed to it using the C++ internal datatype corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype as template parameter for the templated &lt;operator()&gt;(). Ignores vector and array types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>The functor's return type. </td></tr>
    <tr><td class="paramname">Action</td><td>The functor's type. </td></tr>
    <tr><td class="paramname">Args</td><td>The functors argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </td></tr>
    <tr><td class="paramname">action</td><td>The functor. </td></tr>
    <tr><td class="paramname">args</td><td>The functor's arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functor, when calling its &lt;operator()&gt;() with the passed arguments and the template parameter type corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> type. </dd></dl>

</div>
</div>
<a id="a0db326966214149dc4fcdadd22fd7787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db326966214149dc4fcdadd22fd7787">&#9670;&nbsp;</a></span>switchType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto openPMD::switchType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    action. template operator () &lt; char &gt;
    ( std::forward&lt; Args &gt;( args )... ) )
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </p>
<p>Will call the functor passed to it using the C++ internal datatype corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype as template parameter for the templated &lt;operator()&gt;().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>The functor's return type. </td></tr>
    <tr><td class="paramname">Action</td><td>The functor's type. </td></tr>
    <tr><td class="paramname">Args</td><td>The functors argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> datatype. </td></tr>
    <tr><td class="paramname">action</td><td>The functor. </td></tr>
    <tr><td class="paramname">args</td><td>The functor's arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functor, when calling its &lt;operator()&gt;() with the passed arguments and the template parameter type corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api.">openPMD</a> type. </dd></dl>

</div>
</div>
<a id="a31ccc9b338d37af8c6bbbcf4f53dfeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ccc9b338d37af8c6bbbcf4f53dfeee">&#9670;&nbsp;</a></span>toBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t openPMD::toBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bits representing a Datatype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bits </dd></dl>

</div>
</div>
<a id="a9b670ad71d6e80073a7d8fb689b1fd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b670ad71d6e80073a7d8fb689b1fd4a">&#9670;&nbsp;</a></span>toBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t openPMD::toBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes representing a Datatype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
