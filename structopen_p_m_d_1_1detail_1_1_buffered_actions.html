<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>openPMD-api: openPMD::detail::BufferedActions Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openPMD-api
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopen_p_m_d.html">openPMD</a></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html">BufferedActions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structopen_p_m_d_1_1detail_1_1_buffered_actions-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">openPMD::detail::BufferedActions Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for openPMD::detail::BufferedActions:</div>
<div class="dyncontent">
<div class="center"><img src="structopen_p_m_d_1_1detail_1_1_buffered_actions__coll__graph.png" border="0" usemap="#open_p_m_d_1_1detail_1_1_buffered_actions_coll__map" alt="Collaboration graph"/></div>
<map name="open_p_m_d_1_1detail_1_1_buffered_actions_coll__map" id="open_p_m_d_1_1detail_1_1_buffered_actions_coll__map">
<area shape="rect" title=" " alt="" coords="3561,323,3755,364"/>
<area shape="rect" href="structopen_p_m_d_1_1detail_1_1_attribute_reader.html" title=" " alt="" coords="3178,5,3373,47"/>
<area shape="rect" href="structopen_p_m_d_1_1detail_1_1_dataset_reader.html" title=" " alt="" coords="3181,355,3369,396"/>
<area shape="rect" href="classopen_p_m_d_1_1_a_d_i_o_s2_i_o_handler_impl.html" title=" " alt="" coords="2779,315,3013,342"/>
<area shape="rect" href="structopen_p_m_d_1_1detail_1_1_write_dataset.html" title=" " alt="" coords="3164,303,3387,330"/>
<area shape="rect" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl_common.html" title=" " alt="" coords="2347,308,2609,349"/>
<area shape="rect" title=" " alt="" coords="1911,327,2141,368"/>
<area shape="rect" href="structopen_p_m_d_1_1_invalidatable_file.html" title="Wrapper around a shared pointer to:" alt="" coords="1475,334,1673,361"/>
<area shape="rect" title=" " alt="" coords="1909,246,2143,302"/>
<area shape="rect" title=" " alt="" coords="1013,327,1229,368"/>
<area shape="rect" href="structopen_p_m_d_1_1_invalidatable_file_1_1_file_state.html" title=" " alt="" coords="581,327,780,368"/>
<area shape="rect" title="STL class." alt="" coords="257,366,344,393"/>
<area shape="rect" title=" " alt="" coords="993,115,1248,171"/>
<area shape="rect" href="structopen_p_m_d_1_1detail_1_1_buffered_attribute_write.html" title=" " alt="" coords="584,119,777,160"/>
<area shape="rect" title=" " alt="" coords="804,262,969,289"/>
<area shape="rect" href="structopen_p_m_d_1_1detail_1_1_buffered_attribute_read.html" title=" " alt="" coords="1024,513,1217,555"/>
<area shape="rect" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_r_e_a_d___a_t_t_01_4.html" title=" " alt="" coords="585,583,777,624"/>
<area shape="rect" title="STL class." alt="" coords="5,359,144,400"/>
<area shape="rect" href="classopen_p_m_d_1_1_writable.html" title="Layer to mirror structure of logical data and persistent data in file." alt="" coords="1501,246,1647,273"/>
<area shape="rect" title=" " alt="" coords="3175,571,3375,627"/>
<area shape="rect" title=" " alt="" coords="2798,579,2994,620"/>
<area shape="rect" href="structopen_p_m_d_1_1detail_1_1_i___update_span.html" title=" " alt="" coords="2407,579,2549,620"/>
<area shape="rect" href="structopen_p_m_d_1_1detail_1_1_buffered_action.html" title=" " alt="" coords="204,51,397,92"/>
<area shape="rect" title=" " alt="" coords="583,47,779,88"/>
<area shape="rect" title=" " alt="" coords="226,126,375,153"/>
<area shape="rect" href="classopen_p_m_d_1_1detail_1_1_preload_adios_attributes.html" title="Class that is responsible for scheduling and buffering openPMD attribute loads from ADIOS2,..." alt="" coords="3182,652,3369,693"/>
<area shape="rect" title=" " alt="" coords="1272,53,1451,109"/>
<area shape="rect" title=" " alt="" coords="1697,506,1885,562"/>
<area shape="rect" href="structopen_p_m_d_1_1_abstract_parameter.html" title=" " alt="" coords="193,582,408,609"/>
<area shape="rect" title=" " alt="" coords="196,633,405,659"/>
<area shape="rect" title=" " alt="" coords="205,684,396,725"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac8de4d5dbe1bc250787a83a63ab412dc"><td class="memItemLeft" align="right" valign="top"><a id="ac8de4d5dbe1bc250787a83a63ab412dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AttributeMap_t</b> = std::map&lt; std::string, adios2::Params &gt;</td></tr>
<tr class="separator:ac8de4d5dbe1bc250787a83a63ab412dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2dc6c458696cb9d0c1b08d75d4e8c328"><td class="memItemLeft" align="right" valign="top"><a id="a2dc6c458696cb9d0c1b08d75d4e8c328"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BufferedActions</b> (<a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html">BufferedActions</a> const &amp;)=delete</td></tr>
<tr class="separator:a2dc6c458696cb9d0c1b08d75d4e8c328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d6cd41ef82e1ea4852e780875c6a36"><td class="memItemLeft" align="right" valign="top"><a id="a96d6cd41ef82e1ea4852e780875c6a36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BufferedActions</b> (<a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s2_i_o_handler_impl.html">ADIOS2IOHandlerImpl</a> &amp;impl, <a class="el" href="structopen_p_m_d_1_1_invalidatable_file.html">InvalidatableFile</a> file)</td></tr>
<tr class="separator:a96d6cd41ef82e1ea4852e780875c6a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd08110b341f2f805b9e00b60f2eb040"><td class="memItemLeft" align="right" valign="top"><a id="acd08110b341f2f805b9e00b60f2eb040"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#acd08110b341f2f805b9e00b60f2eb040">finalize</a> ()</td></tr>
<tr class="memdesc:acd08110b341f2f805b9e00b60f2eb040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of destructor, will only run once. <br /></td></tr>
<tr class="separator:acd08110b341f2f805b9e00b60f2eb040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64d6c27b6dfaadf98a9471b937e2574"><td class="memItemLeft" align="right" valign="top"><a id="ab64d6c27b6dfaadf98a9471b937e2574"></a>
adios2::Engine &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getEngine</b> ()</td></tr>
<tr class="separator:ab64d6c27b6dfaadf98a9471b937e2574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93716089de994265894ae5567a4f8883"><td class="memItemLeft" align="right" valign="top"><a id="a93716089de994265894ae5567a4f8883"></a>
adios2::Engine &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>requireActiveStep</b> ()</td></tr>
<tr class="separator:a93716089de994265894ae5567a4f8883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d097fa999f004915c5d692aa1fcd6b0"><td class="memTemplParams" colspan="2"><a id="a4d097fa999f004915c5d692aa1fcd6b0"></a>
template&lt;typename BA &gt; </td></tr>
<tr class="memitem:a4d097fa999f004915c5d692aa1fcd6b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enqueue</b> (BA &amp;&amp;ba)</td></tr>
<tr class="separator:a4d097fa999f004915c5d692aa1fcd6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1ce9f974f3166315d3cd333741120c"><td class="memTemplParams" colspan="2"><a id="a9e1ce9f974f3166315d3cd333741120c"></a>
template&lt;typename BA &gt; </td></tr>
<tr class="memitem:a9e1ce9f974f3166315d3cd333741120c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enqueue</b> (BA &amp;&amp;ba, decltype(<a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a3ccdb3db3f101c4827ed79f4e6ac1657">m_buffer</a>) &amp;)</td></tr>
<tr class="separator:a9e1ce9f974f3166315d3cd333741120c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3177ef606d5b5bed513ff7cef7db94c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ae3177ef606d5b5bed513ff7cef7db94c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#ae3177ef606d5b5bed513ff7cef7db94c">flush</a> (<a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065">FlushLevel</a> level, F &amp;&amp;performPutsGets, bool writeAttributes, bool flushUnconditionally)</td></tr>
<tr class="memdesc:ae3177ef606d5b5bed513ff7cef7db94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush deferred IO actions.  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#ae3177ef606d5b5bed513ff7cef7db94c">More...</a><br /></td></tr>
<tr class="separator:ae3177ef606d5b5bed513ff7cef7db94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c43d2ba872a94523ac85a89513f3f2"><td class="memItemLeft" align="right" valign="top"><a id="a51c43d2ba872a94523ac85a89513f3f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a51c43d2ba872a94523ac85a89513f3f2">flush</a> (<a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065">FlushLevel</a>, bool writeAttributes=false)</td></tr>
<tr class="memdesc:a51c43d2ba872a94523ac85a89513f3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#ae3177ef606d5b5bed513ff7cef7db94c" title="Flush deferred IO actions.">flush()</a> that uses adios2::Engine::Perform(Puts|Gets) and does not flush unconditionally. <br /></td></tr>
<tr class="separator:a51c43d2ba872a94523ac85a89513f3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c46eea56fe3806b1028880acdfb0a57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopen_p_m_d.html#a3f85fd5d90639b5642911697a53183d0">AdvanceStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a0c46eea56fe3806b1028880acdfb0a57">advance</a> (<a class="el" href="namespaceopen_p_m_d.html#a1549bb191480b2383a8bdc55da639449">AdvanceMode</a> mode)</td></tr>
<tr class="memdesc:a0c46eea56fe3806b1028880acdfb0a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin or end an ADIOS step.  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a0c46eea56fe3806b1028880acdfb0a57">More...</a><br /></td></tr>
<tr class="separator:a0c46eea56fe3806b1028880acdfb0a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab32e3bc28522b21eae96d1fba5dce27"><td class="memItemLeft" align="right" valign="top"><a id="aab32e3bc28522b21eae96d1fba5dce27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drop</b> ()</td></tr>
<tr class="separator:aab32e3bc28522b21eae96d1fba5dce27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbb2cbf5fc9a18e3ed2969a4dd8c4f8"><td class="memItemLeft" align="right" valign="top"><a id="aebbb2cbf5fc9a18e3ed2969a4dd8c4f8"></a>
const AttributeMap_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>availableAttributes</b> ()</td></tr>
<tr class="separator:aebbb2cbf5fc9a18e3ed2969a4dd8c4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c4db3c7cc4167e5f9442863ad99a13"><td class="memItemLeft" align="right" valign="top"><a id="a01c4db3c7cc4167e5f9442863ad99a13"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>availableAttributesPrefixed</b> (std::string const &amp;prefix)</td></tr>
<tr class="separator:a01c4db3c7cc4167e5f9442863ad99a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5d11d758a2afed1a01c1d0e28ee9c1"><td class="memItemLeft" align="right" valign="top"><a id="a0e5d11d758a2afed1a01c1d0e28ee9c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>invalidateAttributesMap</b> ()</td></tr>
<tr class="separator:a0e5d11d758a2afed1a01c1d0e28ee9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dc979d1327ddc7fa8c02ee0dcd5404"><td class="memItemLeft" align="right" valign="top"><a id="ad3dc979d1327ddc7fa8c02ee0dcd5404"></a>
const AttributeMap_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>availableVariables</b> ()</td></tr>
<tr class="separator:ad3dc979d1327ddc7fa8c02ee0dcd5404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8936d86fb7f61e21bb179b21e1bd20ec"><td class="memItemLeft" align="right" valign="top"><a id="a8936d86fb7f61e21bb179b21e1bd20ec"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>availableVariablesPrefixed</b> (std::string const &amp;prefix)</td></tr>
<tr class="separator:a8936d86fb7f61e21bb179b21e1bd20ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcb6bb668b673a78bf15845e3a1ff23"><td class="memItemLeft" align="right" valign="top"><a id="abbcb6bb668b673a78bf15845e3a1ff23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>invalidateVariablesMap</b> ()</td></tr>
<tr class="separator:abbcb6bb668b673a78bf15845e3a1ff23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a64e34ced5fcf70e745f3e889547871c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a64e34ced5fcf70e745f3e889547871c1">m_file</a></td></tr>
<tr class="memdesc:a64e34ced5fcf70e745f3e889547871c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full path to the file created on disk, including the containing directory and the file extension, as determined by ADIOS2IOHandlerImpl::fileSuffix().  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a64e34ced5fcf70e745f3e889547871c1">More...</a><br /></td></tr>
<tr class="separator:a64e34ced5fcf70e745f3e889547871c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a0eed6f38345de88f9f64be2c307a4"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a82a0eed6f38345de88f9f64be2c307a4">m_IOName</a></td></tr>
<tr class="memdesc:a82a0eed6f38345de88f9f64be2c307a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADIOS requires giving names to instances of adios2::IO.  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a82a0eed6f38345de88f9f64be2c307a4">More...</a><br /></td></tr>
<tr class="separator:a82a0eed6f38345de88f9f64be2c307a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f231a5c171cd9a78e034eedadd9011b"><td class="memItemLeft" align="right" valign="top"><a id="a6f231a5c171cd9a78e034eedadd9011b"></a>
adios2::ADIOS &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_ADIOS</b></td></tr>
<tr class="separator:a6f231a5c171cd9a78e034eedadd9011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad255abded7bc5084043003f139698bae"><td class="memItemLeft" align="right" valign="top"><a id="ad255abded7bc5084043003f139698bae"></a>
adios2::IO&#160;</td><td class="memItemRight" valign="bottom"><b>m_IO</b></td></tr>
<tr class="separator:ad255abded7bc5084043003f139698bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccdb3db3f101c4827ed79f4e6ac1657"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_action.html">BufferedAction</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a3ccdb3db3f101c4827ed79f4e6ac1657">m_buffer</a></td></tr>
<tr class="memdesc:a3ccdb3db3f101c4827ed79f4e6ac1657"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default queue for deferred actions.  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a3ccdb3db3f101c4827ed79f4e6ac1657">More...</a><br /></td></tr>
<tr class="separator:a3ccdb3db3f101c4827ed79f4e6ac1657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695deee7f3e08a8fd7567584fa2f74d2"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_attribute_write.html">BufferedAttributeWrite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a695deee7f3e08a8fd7567584fa2f74d2">m_attributeWrites</a></td></tr>
<tr class="memdesc:a695deee7f3e08a8fd7567584fa2f74d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer for attributes to be written in the new (variable-based) attribute layout.  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a695deee7f3e08a8fd7567584fa2f74d2">More...</a><br /></td></tr>
<tr class="separator:a695deee7f3e08a8fd7567584fa2f74d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213582600af57d4b302717f583e37de9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_attribute_read.html">BufferedAttributeRead</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a213582600af57d4b302717f583e37de9">m_attributeReads</a></td></tr>
<tr class="separator:a213582600af57d4b302717f583e37de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21fb3da18af39891d197cea02b62390"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_action.html">BufferedAction</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#ad21fb3da18af39891d197cea02b62390">m_alreadyEnqueued</a></td></tr>
<tr class="memdesc:ad21fb3da18af39891d197cea02b62390"><td class="mdescLeft">&#160;</td><td class="mdescRight">This contains deferred actions that have already been enqueued into ADIOS2, but not yet performed in ADIOS2.  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#ad21fb3da18af39891d197cea02b62390">More...</a><br /></td></tr>
<tr class="separator:ad21fb3da18af39891d197cea02b62390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bc6aab5de465fa50eef069cef63a13"><td class="memItemLeft" align="right" valign="top"><a id="ae2bc6aab5de465fa50eef069cef63a13"></a>
adios2::Mode&#160;</td><td class="memItemRight" valign="bottom"><b>m_mode</b></td></tr>
<tr class="separator:ae2bc6aab5de465fa50eef069cef63a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780c72d5af2ce9ebfc28e507b0002187"><td class="memItemLeft" align="right" valign="top">std::map&lt; unsigned, std::unique_ptr&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_i___update_span.html">I_UpdateSpan</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a780c72d5af2ce9ebfc28e507b0002187">m_updateSpans</a></td></tr>
<tr class="memdesc:a780c72d5af2ce9ebfc28e507b0002187"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base pointer of an ADIOS2 span might change after reallocations.  <a href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#a780c72d5af2ce9ebfc28e507b0002187">More...</a><br /></td></tr>
<tr class="separator:a780c72d5af2ce9ebfc28e507b0002187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff622beb3c69ab134480553aa2f0bd5"><td class="memItemLeft" align="right" valign="top"><a id="abff622beb3c69ab134480553aa2f0bd5"></a>
const <a class="el" href="structopen_p_m_d_1_1detail_1_1_write_dataset.html">detail::WriteDataset</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_writeDataset</b></td></tr>
<tr class="separator:abff622beb3c69ab134480553aa2f0bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604d19cae0fea8d11e804ac950389f90"><td class="memItemLeft" align="right" valign="top"><a id="a604d19cae0fea8d11e804ac950389f90"></a>
const <a class="el" href="structopen_p_m_d_1_1detail_1_1_dataset_reader.html">detail::DatasetReader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_readDataset</b></td></tr>
<tr class="separator:a604d19cae0fea8d11e804ac950389f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7431c2620b6ce8a893a62b7f00503bd"><td class="memItemLeft" align="right" valign="top"><a id="ac7431c2620b6ce8a893a62b7f00503bd"></a>
const <a class="el" href="structopen_p_m_d_1_1detail_1_1_attribute_reader.html">detail::AttributeReader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_attributeReader</b></td></tr>
<tr class="separator:ac7431c2620b6ce8a893a62b7f00503bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0f4d499714059c2d2f4945e980526a"><td class="memItemLeft" align="right" valign="top"><a id="acf0f4d499714059c2d2f4945e980526a"></a>
<a class="el" href="classopen_p_m_d_1_1detail_1_1_preload_adios_attributes.html">PreloadAdiosAttributes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>preloadAttributes</b></td></tr>
<tr class="separator:acf0f4d499714059c2d2f4945e980526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d115ff1fbe9a0f89433eda77b77c03"><td class="memItemLeft" align="right" valign="top"><a id="a81d115ff1fbe9a0f89433eda77b77c03"></a>
std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>uncommittedAttributes</b></td></tr>
<tr class="separator:a81d115ff1fbe9a0f89433eda77b77c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1542e862c798f0cbbf21e64025550622"><td class="memItemLeft" align="right" valign="top"><a id="a1542e862c798f0cbbf21e64025550622"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>optimizeAttributesStreaming</b> = false</td></tr>
<tr class="separator:a1542e862c798f0cbbf21e64025550622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0c46eea56fe3806b1028880acdfb0a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c46eea56fe3806b1028880acdfb0a57">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopen_p_m_d.html#a3f85fd5d90639b5642911697a53183d0">AdvanceStatus</a> openPMD::detail::BufferedActions::advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a1549bb191480b2383a8bdc55da639449">AdvanceMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin or end an ADIOS step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Whether to begin or end a step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AdvanceStatus </dd></dl>

</div>
</div>
<a id="ae3177ef606d5b5bed513ff7cef7db94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3177ef606d5b5bed513ff7cef7db94c">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void openPMD::detail::BufferedActions::flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a677be01ff3fa0d48536a70114771d065">FlushLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>performPutsGets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushUnconditionally</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush deferred IO actions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Flush Level. Only execute performPutsGets if UserFlush. </td></tr>
    <tr><td class="paramname">performPutsGets</td><td>A functor that takes as parameters (1) *this and (2) the ADIOS2 engine. Its task is to ensure that ADIOS2 performs Put/Get operations. Several options for this:<ul>
<li>adios2::Engine::EndStep</li>
<li>adios2::Engine::Perform(Puts|Gets)</li>
<li>adios2::Engine::Close </li>
</ul>
</td></tr>
    <tr><td class="paramname">writeAttributes</td><td>If using the new attribute layout, perform deferred attribute writes now. </td></tr>
    <tr><td class="paramname">flushUnconditionally</td><td>Whether to run the functor even if no deferred IO tasks had been queued. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad21fb3da18af39891d197cea02b62390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21fb3da18af39891d197cea02b62390">&#9670;&nbsp;</a></span>m_alreadyEnqueued</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_action.html">BufferedAction</a> &gt; &gt; openPMD::detail::BufferedActions::m_alreadyEnqueued</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This contains deferred actions that have already been enqueued into ADIOS2, but not yet performed in ADIOS2. </p>
<p>We must store them somewhere until the next PerformPuts/Gets, EndStep or Close in ADIOS2 to avoid use after free conditions. </p>

</div>
</div>
<a id="a213582600af57d4b302717f583e37de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213582600af57d4b302717f583e37de9">&#9670;&nbsp;</a></span>m_attributeReads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_attribute_read.html">BufferedAttributeRead</a> &gt; openPMD::detail::BufferedActions::m_attributeReads</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>This one is unnecessary, in the new schema, attribute reads do not need to be deferred, but can happen instantly without performance penalty, once preloadAttributes has been filled.</dd></dl>

</div>
</div>
<a id="a695deee7f3e08a8fd7567584fa2f74d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695deee7f3e08a8fd7567584fa2f74d2">&#9670;&nbsp;</a></span>m_attributeWrites</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_attribute_write.html">BufferedAttributeWrite</a> &gt; openPMD::detail::BufferedActions::m_attributeWrites</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer for attributes to be written in the new (variable-based) attribute layout. </p>
<p>Reason: If writing one variable twice within the same ADIOS step, it is undefined which value ADIOS2 will store. We want the last write operation to succeed, so this map stores attribute writes by attribute name, allowing us to override older write commands. The queue is drained only when closing a step / the engine. </p>

</div>
</div>
<a id="a3ccdb3db3f101c4827ed79f4e6ac1657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccdb3db3f101c4827ed79f4e6ac1657">&#9670;&nbsp;</a></span>m_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_action.html">BufferedAction</a> &gt; &gt; openPMD::detail::BufferedActions::m_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default queue for deferred actions. </p>
<p>Drained upon <a class="el" href="structopen_p_m_d_1_1detail_1_1_buffered_actions.html#ae3177ef606d5b5bed513ff7cef7db94c" title="Flush deferred IO actions.">BufferedActions::flush()</a>. </p>

</div>
</div>
<a id="a64e34ced5fcf70e745f3e889547871c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e34ced5fcf70e745f3e889547871c1">&#9670;&nbsp;</a></span>m_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::detail::BufferedActions::m_file</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The full path to the file created on disk, including the containing directory and the file extension, as determined by ADIOS2IOHandlerImpl::fileSuffix(). </p>
<p>(Meaning, in case of the SST engine, no file suffix since the SST engine automatically adds its suffix unconditionally) </p>

</div>
</div>
<a id="a82a0eed6f38345de88f9f64be2c307a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a0eed6f38345de88f9f64be2c307a4">&#9670;&nbsp;</a></span>m_IOName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string openPMD::detail::BufferedActions::m_IOName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADIOS requires giving names to instances of adios2::IO. </p>
<p>We make them different from the actual file name, because of the possible following workflow:</p>
<ol type="1">
<li>create file foo.bp -&gt; would create IO object named foo.bp</li>
<li>delete that file (let's ignore that we don't support deletion yet and call it preplanning)</li>
<li>create file foo.bp a second time -&gt; would create another IO object named foo.bp -&gt; craash</li>
</ol>
<p>So, we just give out names based on a counter for IO objects. Hence, next to the actual file name, also store the name for the IO. </p>

</div>
</div>
<a id="a780c72d5af2ce9ebfc28e507b0002187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780c72d5af2ce9ebfc28e507b0002187">&#9670;&nbsp;</a></span>m_updateSpans</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned, std::unique_ptr&lt; <a class="el" href="structopen_p_m_d_1_1detail_1_1_i___update_span.html">I_UpdateSpan</a> &gt; &gt; openPMD::detail::BufferedActions::m_updateSpans</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base pointer of an ADIOS2 span might change after reallocations. </p>
<p>The frontend will ask the backend for those updated base pointers. Spans given out by the ADIOS2 backend to the frontend are hence identified by an unsigned integer and stored in this member for later retrieval of the updated base pointer. This map is cleared upon flush points. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/tmp/tmp.iS0xscHoW7/openPMD-api/include/openPMD/IO/ADIOS/<a class="el" href="_a_d_i_o_s2_i_o_handler_8hpp_source.html">ADIOS2IOHandler.hpp</a></li>
<li>/tmp/tmp.iS0xscHoW7/openPMD-api/src/IO/ADIOS/ADIOS2IOHandler.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
